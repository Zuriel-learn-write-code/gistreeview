
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Tree
 * 
 */
export type Tree = $Result.DefaultSelection<Prisma.$TreePayload>
/**
 * Model Road
 * 
 */
export type Road = $Result.DefaultSelection<Prisma.$RoadPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model TreePicture
 * 
 */
export type TreePicture = $Result.DefaultSelection<Prisma.$TreePicturePayload>
/**
 * Model RoadPicture
 * 
 */
export type RoadPicture = $Result.DefaultSelection<Prisma.$RoadPicturePayload>
/**
 * Model ReportPicture
 * 
 */
export type ReportPicture = $Result.DefaultSelection<Prisma.$ReportPicturePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  officer: 'officer',
  user: 'user'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TreeStatus: {
  good: 'good',
  warning: 'warning',
  danger: 'danger'
};

export type TreeStatus = (typeof TreeStatus)[keyof typeof TreeStatus]


export const RoadColor: {
  palette_01: 'palette_01',
  palette_02: 'palette_02',
  palette_03: 'palette_03',
  palette_04: 'palette_04',
  palette_05: 'palette_05',
  palette_06: 'palette_06',
  palette_07: 'palette_07',
  palette_08: 'palette_08',
  palette_09: 'palette_09',
  palette_10: 'palette_10'
};

export type RoadColor = (typeof RoadColor)[keyof typeof RoadColor]


export const RoadStatus: {
  primary: 'primary',
  secondary: 'secondary',
  tertiary: 'tertiary',
  unknown: 'unknown'
};

export type RoadStatus = (typeof RoadStatus)[keyof typeof RoadStatus]


export const ReportStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  resolved: 'resolved'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TreeStatus = $Enums.TreeStatus

export const TreeStatus: typeof $Enums.TreeStatus

export type RoadColor = $Enums.RoadColor

export const RoadColor: typeof $Enums.RoadColor

export type RoadStatus = $Enums.RoadStatus

export const RoadStatus: typeof $Enums.RoadStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.tree`: Exposes CRUD operations for the **Tree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trees
    * const trees = await prisma.tree.findMany()
    * ```
    */
  get tree(): Prisma.TreeDelegate<ExtArgs>;

  /**
   * `prisma.road`: Exposes CRUD operations for the **Road** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roads
    * const roads = await prisma.road.findMany()
    * ```
    */
  get road(): Prisma.RoadDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.treePicture`: Exposes CRUD operations for the **TreePicture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreePictures
    * const treePictures = await prisma.treePicture.findMany()
    * ```
    */
  get treePicture(): Prisma.TreePictureDelegate<ExtArgs>;

  /**
   * `prisma.roadPicture`: Exposes CRUD operations for the **RoadPicture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadPictures
    * const roadPictures = await prisma.roadPicture.findMany()
    * ```
    */
  get roadPicture(): Prisma.RoadPictureDelegate<ExtArgs>;

  /**
   * `prisma.reportPicture`: Exposes CRUD operations for the **ReportPicture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportPictures
    * const reportPictures = await prisma.reportPicture.findMany()
    * ```
    */
  get reportPicture(): Prisma.ReportPictureDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Tree: 'Tree',
    Road: 'Road',
    Report: 'Report',
    TreePicture: 'TreePicture',
    RoadPicture: 'RoadPicture',
    ReportPicture: 'ReportPicture'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "tree" | "road" | "report" | "treePicture" | "roadPicture" | "reportPicture"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Tree: {
        payload: Prisma.$TreePayload<ExtArgs>
        fields: Prisma.TreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          findFirst: {
            args: Prisma.TreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          findMany: {
            args: Prisma.TreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>[]
          }
          create: {
            args: Prisma.TreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          createMany: {
            args: Prisma.TreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>[]
          }
          delete: {
            args: Prisma.TreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          update: {
            args: Prisma.TreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          deleteMany: {
            args: Prisma.TreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePayload>
          }
          aggregate: {
            args: Prisma.TreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTree>
          }
          groupBy: {
            args: Prisma.TreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreeCountArgs<ExtArgs>
            result: $Utils.Optional<TreeCountAggregateOutputType> | number
          }
        }
      }
      Road: {
        payload: Prisma.$RoadPayload<ExtArgs>
        fields: Prisma.RoadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          findFirst: {
            args: Prisma.RoadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          findMany: {
            args: Prisma.RoadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>[]
          }
          create: {
            args: Prisma.RoadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          createMany: {
            args: Prisma.RoadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>[]
          }
          delete: {
            args: Prisma.RoadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          update: {
            args: Prisma.RoadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          deleteMany: {
            args: Prisma.RoadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPayload>
          }
          aggregate: {
            args: Prisma.RoadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoad>
          }
          groupBy: {
            args: Prisma.RoadGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadCountArgs<ExtArgs>
            result: $Utils.Optional<RoadCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      TreePicture: {
        payload: Prisma.$TreePicturePayload<ExtArgs>
        fields: Prisma.TreePictureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreePictureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreePictureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          findFirst: {
            args: Prisma.TreePictureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreePictureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          findMany: {
            args: Prisma.TreePictureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>[]
          }
          create: {
            args: Prisma.TreePictureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          createMany: {
            args: Prisma.TreePictureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreePictureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>[]
          }
          delete: {
            args: Prisma.TreePictureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          update: {
            args: Prisma.TreePictureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          deleteMany: {
            args: Prisma.TreePictureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreePictureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreePictureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreePicturePayload>
          }
          aggregate: {
            args: Prisma.TreePictureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreePicture>
          }
          groupBy: {
            args: Prisma.TreePictureGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreePictureGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreePictureCountArgs<ExtArgs>
            result: $Utils.Optional<TreePictureCountAggregateOutputType> | number
          }
        }
      }
      RoadPicture: {
        payload: Prisma.$RoadPicturePayload<ExtArgs>
        fields: Prisma.RoadPictureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadPictureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadPictureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          findFirst: {
            args: Prisma.RoadPictureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadPictureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          findMany: {
            args: Prisma.RoadPictureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>[]
          }
          create: {
            args: Prisma.RoadPictureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          createMany: {
            args: Prisma.RoadPictureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadPictureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>[]
          }
          delete: {
            args: Prisma.RoadPictureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          update: {
            args: Prisma.RoadPictureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          deleteMany: {
            args: Prisma.RoadPictureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadPictureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadPictureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadPicturePayload>
          }
          aggregate: {
            args: Prisma.RoadPictureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadPicture>
          }
          groupBy: {
            args: Prisma.RoadPictureGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadPictureGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadPictureCountArgs<ExtArgs>
            result: $Utils.Optional<RoadPictureCountAggregateOutputType> | number
          }
        }
      }
      ReportPicture: {
        payload: Prisma.$ReportPicturePayload<ExtArgs>
        fields: Prisma.ReportPictureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportPictureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportPictureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          findFirst: {
            args: Prisma.ReportPictureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportPictureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          findMany: {
            args: Prisma.ReportPictureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>[]
          }
          create: {
            args: Prisma.ReportPictureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          createMany: {
            args: Prisma.ReportPictureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportPictureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>[]
          }
          delete: {
            args: Prisma.ReportPictureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          update: {
            args: Prisma.ReportPictureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          deleteMany: {
            args: Prisma.ReportPictureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportPictureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportPictureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPicturePayload>
          }
          aggregate: {
            args: Prisma.ReportPictureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportPicture>
          }
          groupBy: {
            args: Prisma.ReportPictureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportPictureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportPictureCountArgs<ExtArgs>
            result: $Utils.Optional<ReportPictureCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reports: number
    verified: number
    resolved: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    verified?: boolean | UserCountOutputTypeCountVerifiedArgs
    resolved?: boolean | UserCountOutputTypeCountResolvedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type TreeCountOutputType
   */

  export type TreeCountOutputType = {
    reports: number
    treePictures: number
  }

  export type TreeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | TreeCountOutputTypeCountReportsArgs
    treePictures?: boolean | TreeCountOutputTypeCountTreePicturesArgs
  }

  // Custom InputTypes
  /**
   * TreeCountOutputType without action
   */
  export type TreeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeCountOutputType
     */
    select?: TreeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreeCountOutputType without action
   */
  export type TreeCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * TreeCountOutputType without action
   */
  export type TreeCountOutputTypeCountTreePicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreePictureWhereInput
  }


  /**
   * Count Type RoadCountOutputType
   */

  export type RoadCountOutputType = {
    roadPictures: number
    trees: number
  }

  export type RoadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadPictures?: boolean | RoadCountOutputTypeCountRoadPicturesArgs
    trees?: boolean | RoadCountOutputTypeCountTreesArgs
  }

  // Custom InputTypes
  /**
   * RoadCountOutputType without action
   */
  export type RoadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadCountOutputType
     */
    select?: RoadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadCountOutputType without action
   */
  export type RoadCountOutputTypeCountRoadPicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadPictureWhereInput
  }

  /**
   * RoadCountOutputType without action
   */
  export type RoadCountOutputTypeCountTreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreeWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    reportPictures: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportPictures?: boolean | ReportCountOutputTypeCountReportPicturesArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountReportPicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportPictureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    phone: string | null
    userpic: string | null
    bio: string | null
    address: string | null
    country: string | null
    province: string | null
    city: string | null
    postalcode: string | null
    role: $Enums.Role | null
    timestamp: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    phone: string | null
    userpic: string | null
    bio: string | null
    address: string | null
    country: string | null
    province: string | null
    city: string | null
    postalcode: string | null
    role: $Enums.Role | null
    timestamp: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    phone: number
    userpic: number
    bio: number
    address: number
    country: number
    province: number
    city: number
    postalcode: number
    role: number
    timestamp: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone?: true
    userpic?: true
    bio?: true
    address?: true
    country?: true
    province?: true
    city?: true
    postalcode?: true
    role?: true
    timestamp?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone?: true
    userpic?: true
    bio?: true
    address?: true
    country?: true
    province?: true
    city?: true
    postalcode?: true
    role?: true
    timestamp?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone?: true
    userpic?: true
    bio?: true
    address?: true
    country?: true
    province?: true
    city?: true
    postalcode?: true
    role?: true
    timestamp?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone: string | null
    userpic: string | null
    bio: string | null
    address: string | null
    country: string | null
    province: string | null
    city: string | null
    postalcode: string | null
    role: $Enums.Role
    timestamp: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    userpic?: boolean
    bio?: boolean
    address?: boolean
    country?: boolean
    province?: boolean
    city?: boolean
    postalcode?: boolean
    role?: boolean
    timestamp?: boolean
    reports?: boolean | User$reportsArgs<ExtArgs>
    verified?: boolean | User$verifiedArgs<ExtArgs>
    resolved?: boolean | User$resolvedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    userpic?: boolean
    bio?: boolean
    address?: boolean
    country?: boolean
    province?: boolean
    city?: boolean
    postalcode?: boolean
    role?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    userpic?: boolean
    bio?: boolean
    address?: boolean
    country?: boolean
    province?: boolean
    city?: boolean
    postalcode?: boolean
    role?: boolean
    timestamp?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | User$reportsArgs<ExtArgs>
    verified?: boolean | User$verifiedArgs<ExtArgs>
    resolved?: boolean | User$resolvedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      reports: Prisma.$ReportPayload<ExtArgs>[]
      verified: Prisma.$ReportPayload<ExtArgs>[]
      resolved: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstname: string
      lastname: string
      email: string
      password: string
      phone: string | null
      userpic: string | null
      bio: string | null
      address: string | null
      country: string | null
      province: string | null
      city: string | null
      postalcode: string | null
      role: $Enums.Role
      timestamp: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    verified<T extends User$verifiedArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    resolved<T extends User$resolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly userpic: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly province: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly postalcode: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly timestamp: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.verified
   */
  export type User$verifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.resolved
   */
  export type User$resolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Tree
   */

  export type AggregateTree = {
    _count: TreeCountAggregateOutputType | null
    _avg: TreeAvgAggregateOutputType | null
    _sum: TreeSumAggregateOutputType | null
    _min: TreeMinAggregateOutputType | null
    _max: TreeMaxAggregateOutputType | null
  }

  export type TreeAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    age: number | null
    trunk_diameter: number | null
    lbranch_width: number | null
  }

  export type TreeSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    age: number | null
    trunk_diameter: number | null
    lbranch_width: number | null
  }

  export type TreeMinAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    species: string | null
    age: number | null
    trunk_diameter: number | null
    lbranch_width: number | null
    ownership: string | null
    description: string | null
    roadName: string | null
    status: $Enums.TreeStatus | null
    timestamp: Date | null
    roadId: string | null
  }

  export type TreeMaxAggregateOutputType = {
    id: string | null
    latitude: number | null
    longitude: number | null
    species: string | null
    age: number | null
    trunk_diameter: number | null
    lbranch_width: number | null
    ownership: string | null
    description: string | null
    roadName: string | null
    status: $Enums.TreeStatus | null
    timestamp: Date | null
    roadId: string | null
  }

  export type TreeCountAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
    species: number
    age: number
    trunk_diameter: number
    lbranch_width: number
    ownership: number
    description: number
    roadName: number
    status: number
    timestamp: number
    roadId: number
    _all: number
  }


  export type TreeAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    age?: true
    trunk_diameter?: true
    lbranch_width?: true
  }

  export type TreeSumAggregateInputType = {
    latitude?: true
    longitude?: true
    age?: true
    trunk_diameter?: true
    lbranch_width?: true
  }

  export type TreeMinAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    species?: true
    age?: true
    trunk_diameter?: true
    lbranch_width?: true
    ownership?: true
    description?: true
    roadName?: true
    status?: true
    timestamp?: true
    roadId?: true
  }

  export type TreeMaxAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    species?: true
    age?: true
    trunk_diameter?: true
    lbranch_width?: true
    ownership?: true
    description?: true
    roadName?: true
    status?: true
    timestamp?: true
    roadId?: true
  }

  export type TreeCountAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    species?: true
    age?: true
    trunk_diameter?: true
    lbranch_width?: true
    ownership?: true
    description?: true
    roadName?: true
    status?: true
    timestamp?: true
    roadId?: true
    _all?: true
  }

  export type TreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tree to aggregate.
     */
    where?: TreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trees to fetch.
     */
    orderBy?: TreeOrderByWithRelationInput | TreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trees
    **/
    _count?: true | TreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreeMaxAggregateInputType
  }

  export type GetTreeAggregateType<T extends TreeAggregateArgs> = {
        [P in keyof T & keyof AggregateTree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTree[P]>
      : GetScalarType<T[P], AggregateTree[P]>
  }




  export type TreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreeWhereInput
    orderBy?: TreeOrderByWithAggregationInput | TreeOrderByWithAggregationInput[]
    by: TreeScalarFieldEnum[] | TreeScalarFieldEnum
    having?: TreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreeCountAggregateInputType | true
    _avg?: TreeAvgAggregateInputType
    _sum?: TreeSumAggregateInputType
    _min?: TreeMinAggregateInputType
    _max?: TreeMaxAggregateInputType
  }

  export type TreeGroupByOutputType = {
    id: string
    latitude: number
    longitude: number
    species: string | null
    age: number | null
    trunk_diameter: number | null
    lbranch_width: number | null
    ownership: string | null
    description: string | null
    roadName: string | null
    status: $Enums.TreeStatus
    timestamp: Date
    roadId: string | null
    _count: TreeCountAggregateOutputType | null
    _avg: TreeAvgAggregateOutputType | null
    _sum: TreeSumAggregateOutputType | null
    _min: TreeMinAggregateOutputType | null
    _max: TreeMaxAggregateOutputType | null
  }

  type GetTreeGroupByPayload<T extends TreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreeGroupByOutputType[P]>
            : GetScalarType<T[P], TreeGroupByOutputType[P]>
        }
      >
    >


  export type TreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    species?: boolean
    age?: boolean
    trunk_diameter?: boolean
    lbranch_width?: boolean
    ownership?: boolean
    description?: boolean
    roadName?: boolean
    status?: boolean
    timestamp?: boolean
    roadId?: boolean
    road?: boolean | Tree$roadArgs<ExtArgs>
    reports?: boolean | Tree$reportsArgs<ExtArgs>
    treePictures?: boolean | Tree$treePicturesArgs<ExtArgs>
    _count?: boolean | TreeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tree"]>

  export type TreeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    species?: boolean
    age?: boolean
    trunk_diameter?: boolean
    lbranch_width?: boolean
    ownership?: boolean
    description?: boolean
    roadName?: boolean
    status?: boolean
    timestamp?: boolean
    roadId?: boolean
    road?: boolean | Tree$roadArgs<ExtArgs>
  }, ExtArgs["result"]["tree"]>

  export type TreeSelectScalar = {
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    species?: boolean
    age?: boolean
    trunk_diameter?: boolean
    lbranch_width?: boolean
    ownership?: boolean
    description?: boolean
    roadName?: boolean
    status?: boolean
    timestamp?: boolean
    roadId?: boolean
  }

  export type TreeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    road?: boolean | Tree$roadArgs<ExtArgs>
    reports?: boolean | Tree$reportsArgs<ExtArgs>
    treePictures?: boolean | Tree$treePicturesArgs<ExtArgs>
    _count?: boolean | TreeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TreeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    road?: boolean | Tree$roadArgs<ExtArgs>
  }

  export type $TreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tree"
    objects: {
      road: Prisma.$RoadPayload<ExtArgs> | null
      reports: Prisma.$ReportPayload<ExtArgs>[]
      treePictures: Prisma.$TreePicturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      latitude: number
      longitude: number
      species: string | null
      age: number | null
      trunk_diameter: number | null
      lbranch_width: number | null
      ownership: string | null
      description: string | null
      roadName: string | null
      status: $Enums.TreeStatus
      timestamp: Date
      roadId: string | null
    }, ExtArgs["result"]["tree"]>
    composites: {}
  }

  type TreeGetPayload<S extends boolean | null | undefined | TreeDefaultArgs> = $Result.GetResult<Prisma.$TreePayload, S>

  type TreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreeCountAggregateInputType | true
    }

  export interface TreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tree'], meta: { name: 'Tree' } }
    /**
     * Find zero or one Tree that matches the filter.
     * @param {TreeFindUniqueArgs} args - Arguments to find a Tree
     * @example
     * // Get one Tree
     * const tree = await prisma.tree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreeFindUniqueArgs>(args: SelectSubset<T, TreeFindUniqueArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tree that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreeFindUniqueOrThrowArgs} args - Arguments to find a Tree
     * @example
     * // Get one Tree
     * const tree = await prisma.tree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreeFindUniqueOrThrowArgs>(args: SelectSubset<T, TreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeFindFirstArgs} args - Arguments to find a Tree
     * @example
     * // Get one Tree
     * const tree = await prisma.tree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreeFindFirstArgs>(args?: SelectSubset<T, TreeFindFirstArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeFindFirstOrThrowArgs} args - Arguments to find a Tree
     * @example
     * // Get one Tree
     * const tree = await prisma.tree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreeFindFirstOrThrowArgs>(args?: SelectSubset<T, TreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trees
     * const trees = await prisma.tree.findMany()
     * 
     * // Get first 10 Trees
     * const trees = await prisma.tree.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treeWithIdOnly = await prisma.tree.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreeFindManyArgs>(args?: SelectSubset<T, TreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tree.
     * @param {TreeCreateArgs} args - Arguments to create a Tree.
     * @example
     * // Create one Tree
     * const Tree = await prisma.tree.create({
     *   data: {
     *     // ... data to create a Tree
     *   }
     * })
     * 
     */
    create<T extends TreeCreateArgs>(args: SelectSubset<T, TreeCreateArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trees.
     * @param {TreeCreateManyArgs} args - Arguments to create many Trees.
     * @example
     * // Create many Trees
     * const tree = await prisma.tree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreeCreateManyArgs>(args?: SelectSubset<T, TreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trees and returns the data saved in the database.
     * @param {TreeCreateManyAndReturnArgs} args - Arguments to create many Trees.
     * @example
     * // Create many Trees
     * const tree = await prisma.tree.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trees and only return the `id`
     * const treeWithIdOnly = await prisma.tree.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreeCreateManyAndReturnArgs>(args?: SelectSubset<T, TreeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tree.
     * @param {TreeDeleteArgs} args - Arguments to delete one Tree.
     * @example
     * // Delete one Tree
     * const Tree = await prisma.tree.delete({
     *   where: {
     *     // ... filter to delete one Tree
     *   }
     * })
     * 
     */
    delete<T extends TreeDeleteArgs>(args: SelectSubset<T, TreeDeleteArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tree.
     * @param {TreeUpdateArgs} args - Arguments to update one Tree.
     * @example
     * // Update one Tree
     * const tree = await prisma.tree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreeUpdateArgs>(args: SelectSubset<T, TreeUpdateArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trees.
     * @param {TreeDeleteManyArgs} args - Arguments to filter Trees to delete.
     * @example
     * // Delete a few Trees
     * const { count } = await prisma.tree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreeDeleteManyArgs>(args?: SelectSubset<T, TreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trees
     * const tree = await prisma.tree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreeUpdateManyArgs>(args: SelectSubset<T, TreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tree.
     * @param {TreeUpsertArgs} args - Arguments to update or create a Tree.
     * @example
     * // Update or create a Tree
     * const tree = await prisma.tree.upsert({
     *   create: {
     *     // ... data to create a Tree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tree we want to update
     *   }
     * })
     */
    upsert<T extends TreeUpsertArgs>(args: SelectSubset<T, TreeUpsertArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeCountArgs} args - Arguments to filter Trees to count.
     * @example
     * // Count the number of Trees
     * const count = await prisma.tree.count({
     *   where: {
     *     // ... the filter for the Trees we want to count
     *   }
     * })
    **/
    count<T extends TreeCountArgs>(
      args?: Subset<T, TreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreeAggregateArgs>(args: Subset<T, TreeAggregateArgs>): Prisma.PrismaPromise<GetTreeAggregateType<T>>

    /**
     * Group by Tree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreeGroupByArgs['orderBy'] }
        : { orderBy?: TreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tree model
   */
  readonly fields: TreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    road<T extends Tree$roadArgs<ExtArgs> = {}>(args?: Subset<T, Tree$roadArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reports<T extends Tree$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Tree$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    treePictures<T extends Tree$treePicturesArgs<ExtArgs> = {}>(args?: Subset<T, Tree$treePicturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tree model
   */ 
  interface TreeFieldRefs {
    readonly id: FieldRef<"Tree", 'String'>
    readonly latitude: FieldRef<"Tree", 'Float'>
    readonly longitude: FieldRef<"Tree", 'Float'>
    readonly species: FieldRef<"Tree", 'String'>
    readonly age: FieldRef<"Tree", 'Int'>
    readonly trunk_diameter: FieldRef<"Tree", 'Float'>
    readonly lbranch_width: FieldRef<"Tree", 'Float'>
    readonly ownership: FieldRef<"Tree", 'String'>
    readonly description: FieldRef<"Tree", 'String'>
    readonly roadName: FieldRef<"Tree", 'String'>
    readonly status: FieldRef<"Tree", 'TreeStatus'>
    readonly timestamp: FieldRef<"Tree", 'DateTime'>
    readonly roadId: FieldRef<"Tree", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tree findUnique
   */
  export type TreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter, which Tree to fetch.
     */
    where: TreeWhereUniqueInput
  }

  /**
   * Tree findUniqueOrThrow
   */
  export type TreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter, which Tree to fetch.
     */
    where: TreeWhereUniqueInput
  }

  /**
   * Tree findFirst
   */
  export type TreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter, which Tree to fetch.
     */
    where?: TreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trees to fetch.
     */
    orderBy?: TreeOrderByWithRelationInput | TreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trees.
     */
    cursor?: TreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trees.
     */
    distinct?: TreeScalarFieldEnum | TreeScalarFieldEnum[]
  }

  /**
   * Tree findFirstOrThrow
   */
  export type TreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter, which Tree to fetch.
     */
    where?: TreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trees to fetch.
     */
    orderBy?: TreeOrderByWithRelationInput | TreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trees.
     */
    cursor?: TreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trees.
     */
    distinct?: TreeScalarFieldEnum | TreeScalarFieldEnum[]
  }

  /**
   * Tree findMany
   */
  export type TreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter, which Trees to fetch.
     */
    where?: TreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trees to fetch.
     */
    orderBy?: TreeOrderByWithRelationInput | TreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trees.
     */
    cursor?: TreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trees.
     */
    skip?: number
    distinct?: TreeScalarFieldEnum | TreeScalarFieldEnum[]
  }

  /**
   * Tree create
   */
  export type TreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * The data needed to create a Tree.
     */
    data: XOR<TreeCreateInput, TreeUncheckedCreateInput>
  }

  /**
   * Tree createMany
   */
  export type TreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trees.
     */
    data: TreeCreateManyInput | TreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tree createManyAndReturn
   */
  export type TreeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trees.
     */
    data: TreeCreateManyInput | TreeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tree update
   */
  export type TreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * The data needed to update a Tree.
     */
    data: XOR<TreeUpdateInput, TreeUncheckedUpdateInput>
    /**
     * Choose, which Tree to update.
     */
    where: TreeWhereUniqueInput
  }

  /**
   * Tree updateMany
   */
  export type TreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trees.
     */
    data: XOR<TreeUpdateManyMutationInput, TreeUncheckedUpdateManyInput>
    /**
     * Filter which Trees to update
     */
    where?: TreeWhereInput
  }

  /**
   * Tree upsert
   */
  export type TreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * The filter to search for the Tree to update in case it exists.
     */
    where: TreeWhereUniqueInput
    /**
     * In case the Tree found by the `where` argument doesn't exist, create a new Tree with this data.
     */
    create: XOR<TreeCreateInput, TreeUncheckedCreateInput>
    /**
     * In case the Tree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreeUpdateInput, TreeUncheckedUpdateInput>
  }

  /**
   * Tree delete
   */
  export type TreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    /**
     * Filter which Tree to delete.
     */
    where: TreeWhereUniqueInput
  }

  /**
   * Tree deleteMany
   */
  export type TreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trees to delete
     */
    where?: TreeWhereInput
  }

  /**
   * Tree.road
   */
  export type Tree$roadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    where?: RoadWhereInput
  }

  /**
   * Tree.reports
   */
  export type Tree$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Tree.treePictures
   */
  export type Tree$treePicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    where?: TreePictureWhereInput
    orderBy?: TreePictureOrderByWithRelationInput | TreePictureOrderByWithRelationInput[]
    cursor?: TreePictureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreePictureScalarFieldEnum | TreePictureScalarFieldEnum[]
  }

  /**
   * Tree without action
   */
  export type TreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
  }


  /**
   * Model Road
   */

  export type AggregateRoad = {
    _count: RoadCountAggregateOutputType | null
    _min: RoadMinAggregateOutputType | null
    _max: RoadMaxAggregateOutputType | null
  }

  export type RoadMinAggregateOutputType = {
    id: string | null
    nameroad: string | null
    description: string | null
    source_osm_id: string | null
    osm_type: string | null
    color: $Enums.RoadColor | null
    status: $Enums.RoadStatus | null
  }

  export type RoadMaxAggregateOutputType = {
    id: string | null
    nameroad: string | null
    description: string | null
    source_osm_id: string | null
    osm_type: string | null
    color: $Enums.RoadColor | null
    status: $Enums.RoadStatus | null
  }

  export type RoadCountAggregateOutputType = {
    id: number
    nameroad: number
    description: number
    geometry: number
    source_osm_id: number
    osm_type: number
    osm_tags: number
    osm_properties: number
    color: number
    status: number
    _all: number
  }


  export type RoadMinAggregateInputType = {
    id?: true
    nameroad?: true
    description?: true
    source_osm_id?: true
    osm_type?: true
    color?: true
    status?: true
  }

  export type RoadMaxAggregateInputType = {
    id?: true
    nameroad?: true
    description?: true
    source_osm_id?: true
    osm_type?: true
    color?: true
    status?: true
  }

  export type RoadCountAggregateInputType = {
    id?: true
    nameroad?: true
    description?: true
    geometry?: true
    source_osm_id?: true
    osm_type?: true
    osm_tags?: true
    osm_properties?: true
    color?: true
    status?: true
    _all?: true
  }

  export type RoadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Road to aggregate.
     */
    where?: RoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roads to fetch.
     */
    orderBy?: RoadOrderByWithRelationInput | RoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roads
    **/
    _count?: true | RoadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadMaxAggregateInputType
  }

  export type GetRoadAggregateType<T extends RoadAggregateArgs> = {
        [P in keyof T & keyof AggregateRoad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoad[P]>
      : GetScalarType<T[P], AggregateRoad[P]>
  }




  export type RoadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadWhereInput
    orderBy?: RoadOrderByWithAggregationInput | RoadOrderByWithAggregationInput[]
    by: RoadScalarFieldEnum[] | RoadScalarFieldEnum
    having?: RoadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadCountAggregateInputType | true
    _min?: RoadMinAggregateInputType
    _max?: RoadMaxAggregateInputType
  }

  export type RoadGroupByOutputType = {
    id: string
    nameroad: string | null
    description: string | null
    geometry: JsonValue | null
    source_osm_id: string | null
    osm_type: string | null
    osm_tags: JsonValue | null
    osm_properties: JsonValue | null
    color: $Enums.RoadColor | null
    status: $Enums.RoadStatus
    _count: RoadCountAggregateOutputType | null
    _min: RoadMinAggregateOutputType | null
    _max: RoadMaxAggregateOutputType | null
  }

  type GetRoadGroupByPayload<T extends RoadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadGroupByOutputType[P]>
            : GetScalarType<T[P], RoadGroupByOutputType[P]>
        }
      >
    >


  export type RoadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameroad?: boolean
    description?: boolean
    geometry?: boolean
    source_osm_id?: boolean
    osm_type?: boolean
    osm_tags?: boolean
    osm_properties?: boolean
    color?: boolean
    status?: boolean
    roadPictures?: boolean | Road$roadPicturesArgs<ExtArgs>
    trees?: boolean | Road$treesArgs<ExtArgs>
    _count?: boolean | RoadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["road"]>

  export type RoadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameroad?: boolean
    description?: boolean
    geometry?: boolean
    source_osm_id?: boolean
    osm_type?: boolean
    osm_tags?: boolean
    osm_properties?: boolean
    color?: boolean
    status?: boolean
  }, ExtArgs["result"]["road"]>

  export type RoadSelectScalar = {
    id?: boolean
    nameroad?: boolean
    description?: boolean
    geometry?: boolean
    source_osm_id?: boolean
    osm_type?: boolean
    osm_tags?: boolean
    osm_properties?: boolean
    color?: boolean
    status?: boolean
  }

  export type RoadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadPictures?: boolean | Road$roadPicturesArgs<ExtArgs>
    trees?: boolean | Road$treesArgs<ExtArgs>
    _count?: boolean | RoadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Road"
    objects: {
      roadPictures: Prisma.$RoadPicturePayload<ExtArgs>[]
      trees: Prisma.$TreePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameroad: string | null
      description: string | null
      geometry: Prisma.JsonValue | null
      source_osm_id: string | null
      osm_type: string | null
      osm_tags: Prisma.JsonValue | null
      osm_properties: Prisma.JsonValue | null
      color: $Enums.RoadColor | null
      status: $Enums.RoadStatus
    }, ExtArgs["result"]["road"]>
    composites: {}
  }

  type RoadGetPayload<S extends boolean | null | undefined | RoadDefaultArgs> = $Result.GetResult<Prisma.$RoadPayload, S>

  type RoadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadCountAggregateInputType | true
    }

  export interface RoadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Road'], meta: { name: 'Road' } }
    /**
     * Find zero or one Road that matches the filter.
     * @param {RoadFindUniqueArgs} args - Arguments to find a Road
     * @example
     * // Get one Road
     * const road = await prisma.road.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadFindUniqueArgs>(args: SelectSubset<T, RoadFindUniqueArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Road that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadFindUniqueOrThrowArgs} args - Arguments to find a Road
     * @example
     * // Get one Road
     * const road = await prisma.road.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Road that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadFindFirstArgs} args - Arguments to find a Road
     * @example
     * // Get one Road
     * const road = await prisma.road.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadFindFirstArgs>(args?: SelectSubset<T, RoadFindFirstArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Road that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadFindFirstOrThrowArgs} args - Arguments to find a Road
     * @example
     * // Get one Road
     * const road = await prisma.road.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roads
     * const roads = await prisma.road.findMany()
     * 
     * // Get first 10 Roads
     * const roads = await prisma.road.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadWithIdOnly = await prisma.road.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadFindManyArgs>(args?: SelectSubset<T, RoadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Road.
     * @param {RoadCreateArgs} args - Arguments to create a Road.
     * @example
     * // Create one Road
     * const Road = await prisma.road.create({
     *   data: {
     *     // ... data to create a Road
     *   }
     * })
     * 
     */
    create<T extends RoadCreateArgs>(args: SelectSubset<T, RoadCreateArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roads.
     * @param {RoadCreateManyArgs} args - Arguments to create many Roads.
     * @example
     * // Create many Roads
     * const road = await prisma.road.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadCreateManyArgs>(args?: SelectSubset<T, RoadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roads and returns the data saved in the database.
     * @param {RoadCreateManyAndReturnArgs} args - Arguments to create many Roads.
     * @example
     * // Create many Roads
     * const road = await prisma.road.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roads and only return the `id`
     * const roadWithIdOnly = await prisma.road.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Road.
     * @param {RoadDeleteArgs} args - Arguments to delete one Road.
     * @example
     * // Delete one Road
     * const Road = await prisma.road.delete({
     *   where: {
     *     // ... filter to delete one Road
     *   }
     * })
     * 
     */
    delete<T extends RoadDeleteArgs>(args: SelectSubset<T, RoadDeleteArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Road.
     * @param {RoadUpdateArgs} args - Arguments to update one Road.
     * @example
     * // Update one Road
     * const road = await prisma.road.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadUpdateArgs>(args: SelectSubset<T, RoadUpdateArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roads.
     * @param {RoadDeleteManyArgs} args - Arguments to filter Roads to delete.
     * @example
     * // Delete a few Roads
     * const { count } = await prisma.road.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadDeleteManyArgs>(args?: SelectSubset<T, RoadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roads
     * const road = await prisma.road.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadUpdateManyArgs>(args: SelectSubset<T, RoadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Road.
     * @param {RoadUpsertArgs} args - Arguments to update or create a Road.
     * @example
     * // Update or create a Road
     * const road = await prisma.road.upsert({
     *   create: {
     *     // ... data to create a Road
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Road we want to update
     *   }
     * })
     */
    upsert<T extends RoadUpsertArgs>(args: SelectSubset<T, RoadUpsertArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadCountArgs} args - Arguments to filter Roads to count.
     * @example
     * // Count the number of Roads
     * const count = await prisma.road.count({
     *   where: {
     *     // ... the filter for the Roads we want to count
     *   }
     * })
    **/
    count<T extends RoadCountArgs>(
      args?: Subset<T, RoadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Road.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadAggregateArgs>(args: Subset<T, RoadAggregateArgs>): Prisma.PrismaPromise<GetRoadAggregateType<T>>

    /**
     * Group by Road.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadGroupByArgs['orderBy'] }
        : { orderBy?: RoadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Road model
   */
  readonly fields: RoadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Road.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadPictures<T extends Road$roadPicturesArgs<ExtArgs> = {}>(args?: Subset<T, Road$roadPicturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findMany"> | Null>
    trees<T extends Road$treesArgs<ExtArgs> = {}>(args?: Subset<T, Road$treesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Road model
   */ 
  interface RoadFieldRefs {
    readonly id: FieldRef<"Road", 'String'>
    readonly nameroad: FieldRef<"Road", 'String'>
    readonly description: FieldRef<"Road", 'String'>
    readonly geometry: FieldRef<"Road", 'Json'>
    readonly source_osm_id: FieldRef<"Road", 'String'>
    readonly osm_type: FieldRef<"Road", 'String'>
    readonly osm_tags: FieldRef<"Road", 'Json'>
    readonly osm_properties: FieldRef<"Road", 'Json'>
    readonly color: FieldRef<"Road", 'RoadColor'>
    readonly status: FieldRef<"Road", 'RoadStatus'>
  }
    

  // Custom InputTypes
  /**
   * Road findUnique
   */
  export type RoadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter, which Road to fetch.
     */
    where: RoadWhereUniqueInput
  }

  /**
   * Road findUniqueOrThrow
   */
  export type RoadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter, which Road to fetch.
     */
    where: RoadWhereUniqueInput
  }

  /**
   * Road findFirst
   */
  export type RoadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter, which Road to fetch.
     */
    where?: RoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roads to fetch.
     */
    orderBy?: RoadOrderByWithRelationInput | RoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roads.
     */
    cursor?: RoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roads.
     */
    distinct?: RoadScalarFieldEnum | RoadScalarFieldEnum[]
  }

  /**
   * Road findFirstOrThrow
   */
  export type RoadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter, which Road to fetch.
     */
    where?: RoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roads to fetch.
     */
    orderBy?: RoadOrderByWithRelationInput | RoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roads.
     */
    cursor?: RoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roads.
     */
    distinct?: RoadScalarFieldEnum | RoadScalarFieldEnum[]
  }

  /**
   * Road findMany
   */
  export type RoadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter, which Roads to fetch.
     */
    where?: RoadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roads to fetch.
     */
    orderBy?: RoadOrderByWithRelationInput | RoadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roads.
     */
    cursor?: RoadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roads.
     */
    skip?: number
    distinct?: RoadScalarFieldEnum | RoadScalarFieldEnum[]
  }

  /**
   * Road create
   */
  export type RoadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * The data needed to create a Road.
     */
    data?: XOR<RoadCreateInput, RoadUncheckedCreateInput>
  }

  /**
   * Road createMany
   */
  export type RoadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roads.
     */
    data: RoadCreateManyInput | RoadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Road createManyAndReturn
   */
  export type RoadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roads.
     */
    data: RoadCreateManyInput | RoadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Road update
   */
  export type RoadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * The data needed to update a Road.
     */
    data: XOR<RoadUpdateInput, RoadUncheckedUpdateInput>
    /**
     * Choose, which Road to update.
     */
    where: RoadWhereUniqueInput
  }

  /**
   * Road updateMany
   */
  export type RoadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roads.
     */
    data: XOR<RoadUpdateManyMutationInput, RoadUncheckedUpdateManyInput>
    /**
     * Filter which Roads to update
     */
    where?: RoadWhereInput
  }

  /**
   * Road upsert
   */
  export type RoadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * The filter to search for the Road to update in case it exists.
     */
    where: RoadWhereUniqueInput
    /**
     * In case the Road found by the `where` argument doesn't exist, create a new Road with this data.
     */
    create: XOR<RoadCreateInput, RoadUncheckedCreateInput>
    /**
     * In case the Road was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadUpdateInput, RoadUncheckedUpdateInput>
  }

  /**
   * Road delete
   */
  export type RoadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
    /**
     * Filter which Road to delete.
     */
    where: RoadWhereUniqueInput
  }

  /**
   * Road deleteMany
   */
  export type RoadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roads to delete
     */
    where?: RoadWhereInput
  }

  /**
   * Road.roadPictures
   */
  export type Road$roadPicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    where?: RoadPictureWhereInput
    orderBy?: RoadPictureOrderByWithRelationInput | RoadPictureOrderByWithRelationInput[]
    cursor?: RoadPictureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadPictureScalarFieldEnum | RoadPictureScalarFieldEnum[]
  }

  /**
   * Road.trees
   */
  export type Road$treesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    where?: TreeWhereInput
    orderBy?: TreeOrderByWithRelationInput | TreeOrderByWithRelationInput[]
    cursor?: TreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreeScalarFieldEnum | TreeScalarFieldEnum[]
  }

  /**
   * Road without action
   */
  export type RoadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Road
     */
    select?: RoadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    treeId: string | null
    description: string | null
    status: $Enums.ReportStatus | null
    timestamp: Date | null
    verifiedById: string | null
    resolvedById: string | null
    resolvedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    treeId: string | null
    description: string | null
    status: $Enums.ReportStatus | null
    timestamp: Date | null
    verifiedById: string | null
    resolvedById: string | null
    resolvedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    userId: number
    treeId: number
    description: number
    status: number
    timestamp: number
    verifiedById: number
    resolvedById: number
    resolvedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    userId?: true
    treeId?: true
    description?: true
    status?: true
    timestamp?: true
    verifiedById?: true
    resolvedById?: true
    resolvedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    userId?: true
    treeId?: true
    description?: true
    status?: true
    timestamp?: true
    verifiedById?: true
    resolvedById?: true
    resolvedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    userId?: true
    treeId?: true
    description?: true
    status?: true
    timestamp?: true
    verifiedById?: true
    resolvedById?: true
    resolvedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    userId: string | null
    treeId: string | null
    description: string | null
    status: $Enums.ReportStatus
    timestamp: Date
    verifiedById: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    treeId?: boolean
    description?: boolean
    status?: boolean
    timestamp?: boolean
    verifiedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    user?: boolean | Report$userArgs<ExtArgs>
    tree?: boolean | Report$treeArgs<ExtArgs>
    verifiedBy?: boolean | Report$verifiedByArgs<ExtArgs>
    resolvedBy?: boolean | Report$resolvedByArgs<ExtArgs>
    reportPictures?: boolean | Report$reportPicturesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    treeId?: boolean
    description?: boolean
    status?: boolean
    timestamp?: boolean
    verifiedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    user?: boolean | Report$userArgs<ExtArgs>
    tree?: boolean | Report$treeArgs<ExtArgs>
    verifiedBy?: boolean | Report$verifiedByArgs<ExtArgs>
    resolvedBy?: boolean | Report$resolvedByArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    userId?: boolean
    treeId?: boolean
    description?: boolean
    status?: boolean
    timestamp?: boolean
    verifiedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Report$userArgs<ExtArgs>
    tree?: boolean | Report$treeArgs<ExtArgs>
    verifiedBy?: boolean | Report$verifiedByArgs<ExtArgs>
    resolvedBy?: boolean | Report$resolvedByArgs<ExtArgs>
    reportPictures?: boolean | Report$reportPicturesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Report$userArgs<ExtArgs>
    tree?: boolean | Report$treeArgs<ExtArgs>
    verifiedBy?: boolean | Report$verifiedByArgs<ExtArgs>
    resolvedBy?: boolean | Report$resolvedByArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      tree: Prisma.$TreePayload<ExtArgs> | null
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
      reportPictures: Prisma.$ReportPicturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      treeId: string | null
      description: string | null
      status: $Enums.ReportStatus
      timestamp: Date
      verifiedById: string | null
      resolvedById: string | null
      resolvedAt: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Report$userArgs<ExtArgs> = {}>(args?: Subset<T, Report$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tree<T extends Report$treeArgs<ExtArgs> = {}>(args?: Subset<T, Report$treeArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    verifiedBy<T extends Report$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, Report$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    resolvedBy<T extends Report$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, Report$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reportPictures<T extends Report$reportPicturesArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportPicturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly treeId: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly timestamp: FieldRef<"Report", 'DateTime'>
    readonly verifiedById: FieldRef<"Report", 'String'>
    readonly resolvedById: FieldRef<"Report", 'String'>
    readonly resolvedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data?: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.user
   */
  export type Report$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.tree
   */
  export type Report$treeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tree
     */
    select?: TreeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeInclude<ExtArgs> | null
    where?: TreeWhereInput
  }

  /**
   * Report.verifiedBy
   */
  export type Report$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.resolvedBy
   */
  export type Report$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Report.reportPictures
   */
  export type Report$reportPicturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    where?: ReportPictureWhereInput
    orderBy?: ReportPictureOrderByWithRelationInput | ReportPictureOrderByWithRelationInput[]
    cursor?: ReportPictureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportPictureScalarFieldEnum | ReportPictureScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model TreePicture
   */

  export type AggregateTreePicture = {
    _count: TreePictureCountAggregateOutputType | null
    _min: TreePictureMinAggregateOutputType | null
    _max: TreePictureMaxAggregateOutputType | null
  }

  export type TreePictureMinAggregateOutputType = {
    id: string | null
    url: string | null
    treeId: string | null
    uploaded: Date | null
  }

  export type TreePictureMaxAggregateOutputType = {
    id: string | null
    url: string | null
    treeId: string | null
    uploaded: Date | null
  }

  export type TreePictureCountAggregateOutputType = {
    id: number
    url: number
    treeId: number
    uploaded: number
    _all: number
  }


  export type TreePictureMinAggregateInputType = {
    id?: true
    url?: true
    treeId?: true
    uploaded?: true
  }

  export type TreePictureMaxAggregateInputType = {
    id?: true
    url?: true
    treeId?: true
    uploaded?: true
  }

  export type TreePictureCountAggregateInputType = {
    id?: true
    url?: true
    treeId?: true
    uploaded?: true
    _all?: true
  }

  export type TreePictureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreePicture to aggregate.
     */
    where?: TreePictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreePictures to fetch.
     */
    orderBy?: TreePictureOrderByWithRelationInput | TreePictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreePictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreePictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreePictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreePictures
    **/
    _count?: true | TreePictureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreePictureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreePictureMaxAggregateInputType
  }

  export type GetTreePictureAggregateType<T extends TreePictureAggregateArgs> = {
        [P in keyof T & keyof AggregateTreePicture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreePicture[P]>
      : GetScalarType<T[P], AggregateTreePicture[P]>
  }




  export type TreePictureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreePictureWhereInput
    orderBy?: TreePictureOrderByWithAggregationInput | TreePictureOrderByWithAggregationInput[]
    by: TreePictureScalarFieldEnum[] | TreePictureScalarFieldEnum
    having?: TreePictureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreePictureCountAggregateInputType | true
    _min?: TreePictureMinAggregateInputType
    _max?: TreePictureMaxAggregateInputType
  }

  export type TreePictureGroupByOutputType = {
    id: string
    url: string
    treeId: string
    uploaded: Date
    _count: TreePictureCountAggregateOutputType | null
    _min: TreePictureMinAggregateOutputType | null
    _max: TreePictureMaxAggregateOutputType | null
  }

  type GetTreePictureGroupByPayload<T extends TreePictureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreePictureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreePictureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreePictureGroupByOutputType[P]>
            : GetScalarType<T[P], TreePictureGroupByOutputType[P]>
        }
      >
    >


  export type TreePictureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    treeId?: boolean
    uploaded?: boolean
    tree?: boolean | TreeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treePicture"]>

  export type TreePictureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    treeId?: boolean
    uploaded?: boolean
    tree?: boolean | TreeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treePicture"]>

  export type TreePictureSelectScalar = {
    id?: boolean
    url?: boolean
    treeId?: boolean
    uploaded?: boolean
  }

  export type TreePictureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tree?: boolean | TreeDefaultArgs<ExtArgs>
  }
  export type TreePictureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tree?: boolean | TreeDefaultArgs<ExtArgs>
  }

  export type $TreePicturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreePicture"
    objects: {
      tree: Prisma.$TreePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      treeId: string
      uploaded: Date
    }, ExtArgs["result"]["treePicture"]>
    composites: {}
  }

  type TreePictureGetPayload<S extends boolean | null | undefined | TreePictureDefaultArgs> = $Result.GetResult<Prisma.$TreePicturePayload, S>

  type TreePictureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreePictureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreePictureCountAggregateInputType | true
    }

  export interface TreePictureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreePicture'], meta: { name: 'TreePicture' } }
    /**
     * Find zero or one TreePicture that matches the filter.
     * @param {TreePictureFindUniqueArgs} args - Arguments to find a TreePicture
     * @example
     * // Get one TreePicture
     * const treePicture = await prisma.treePicture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreePictureFindUniqueArgs>(args: SelectSubset<T, TreePictureFindUniqueArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TreePicture that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreePictureFindUniqueOrThrowArgs} args - Arguments to find a TreePicture
     * @example
     * // Get one TreePicture
     * const treePicture = await prisma.treePicture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreePictureFindUniqueOrThrowArgs>(args: SelectSubset<T, TreePictureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TreePicture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureFindFirstArgs} args - Arguments to find a TreePicture
     * @example
     * // Get one TreePicture
     * const treePicture = await prisma.treePicture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreePictureFindFirstArgs>(args?: SelectSubset<T, TreePictureFindFirstArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TreePicture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureFindFirstOrThrowArgs} args - Arguments to find a TreePicture
     * @example
     * // Get one TreePicture
     * const treePicture = await prisma.treePicture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreePictureFindFirstOrThrowArgs>(args?: SelectSubset<T, TreePictureFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TreePictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreePictures
     * const treePictures = await prisma.treePicture.findMany()
     * 
     * // Get first 10 TreePictures
     * const treePictures = await prisma.treePicture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treePictureWithIdOnly = await prisma.treePicture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreePictureFindManyArgs>(args?: SelectSubset<T, TreePictureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TreePicture.
     * @param {TreePictureCreateArgs} args - Arguments to create a TreePicture.
     * @example
     * // Create one TreePicture
     * const TreePicture = await prisma.treePicture.create({
     *   data: {
     *     // ... data to create a TreePicture
     *   }
     * })
     * 
     */
    create<T extends TreePictureCreateArgs>(args: SelectSubset<T, TreePictureCreateArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TreePictures.
     * @param {TreePictureCreateManyArgs} args - Arguments to create many TreePictures.
     * @example
     * // Create many TreePictures
     * const treePicture = await prisma.treePicture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreePictureCreateManyArgs>(args?: SelectSubset<T, TreePictureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TreePictures and returns the data saved in the database.
     * @param {TreePictureCreateManyAndReturnArgs} args - Arguments to create many TreePictures.
     * @example
     * // Create many TreePictures
     * const treePicture = await prisma.treePicture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TreePictures and only return the `id`
     * const treePictureWithIdOnly = await prisma.treePicture.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreePictureCreateManyAndReturnArgs>(args?: SelectSubset<T, TreePictureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TreePicture.
     * @param {TreePictureDeleteArgs} args - Arguments to delete one TreePicture.
     * @example
     * // Delete one TreePicture
     * const TreePicture = await prisma.treePicture.delete({
     *   where: {
     *     // ... filter to delete one TreePicture
     *   }
     * })
     * 
     */
    delete<T extends TreePictureDeleteArgs>(args: SelectSubset<T, TreePictureDeleteArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TreePicture.
     * @param {TreePictureUpdateArgs} args - Arguments to update one TreePicture.
     * @example
     * // Update one TreePicture
     * const treePicture = await prisma.treePicture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreePictureUpdateArgs>(args: SelectSubset<T, TreePictureUpdateArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TreePictures.
     * @param {TreePictureDeleteManyArgs} args - Arguments to filter TreePictures to delete.
     * @example
     * // Delete a few TreePictures
     * const { count } = await prisma.treePicture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreePictureDeleteManyArgs>(args?: SelectSubset<T, TreePictureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreePictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreePictures
     * const treePicture = await prisma.treePicture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreePictureUpdateManyArgs>(args: SelectSubset<T, TreePictureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TreePicture.
     * @param {TreePictureUpsertArgs} args - Arguments to update or create a TreePicture.
     * @example
     * // Update or create a TreePicture
     * const treePicture = await prisma.treePicture.upsert({
     *   create: {
     *     // ... data to create a TreePicture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreePicture we want to update
     *   }
     * })
     */
    upsert<T extends TreePictureUpsertArgs>(args: SelectSubset<T, TreePictureUpsertArgs<ExtArgs>>): Prisma__TreePictureClient<$Result.GetResult<Prisma.$TreePicturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TreePictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureCountArgs} args - Arguments to filter TreePictures to count.
     * @example
     * // Count the number of TreePictures
     * const count = await prisma.treePicture.count({
     *   where: {
     *     // ... the filter for the TreePictures we want to count
     *   }
     * })
    **/
    count<T extends TreePictureCountArgs>(
      args?: Subset<T, TreePictureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreePictureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreePicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreePictureAggregateArgs>(args: Subset<T, TreePictureAggregateArgs>): Prisma.PrismaPromise<GetTreePictureAggregateType<T>>

    /**
     * Group by TreePicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreePictureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreePictureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreePictureGroupByArgs['orderBy'] }
        : { orderBy?: TreePictureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreePictureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreePictureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreePicture model
   */
  readonly fields: TreePictureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreePicture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreePictureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tree<T extends TreeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreeDefaultArgs<ExtArgs>>): Prisma__TreeClient<$Result.GetResult<Prisma.$TreePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreePicture model
   */ 
  interface TreePictureFieldRefs {
    readonly id: FieldRef<"TreePicture", 'String'>
    readonly url: FieldRef<"TreePicture", 'String'>
    readonly treeId: FieldRef<"TreePicture", 'String'>
    readonly uploaded: FieldRef<"TreePicture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TreePicture findUnique
   */
  export type TreePictureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter, which TreePicture to fetch.
     */
    where: TreePictureWhereUniqueInput
  }

  /**
   * TreePicture findUniqueOrThrow
   */
  export type TreePictureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter, which TreePicture to fetch.
     */
    where: TreePictureWhereUniqueInput
  }

  /**
   * TreePicture findFirst
   */
  export type TreePictureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter, which TreePicture to fetch.
     */
    where?: TreePictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreePictures to fetch.
     */
    orderBy?: TreePictureOrderByWithRelationInput | TreePictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreePictures.
     */
    cursor?: TreePictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreePictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreePictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreePictures.
     */
    distinct?: TreePictureScalarFieldEnum | TreePictureScalarFieldEnum[]
  }

  /**
   * TreePicture findFirstOrThrow
   */
  export type TreePictureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter, which TreePicture to fetch.
     */
    where?: TreePictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreePictures to fetch.
     */
    orderBy?: TreePictureOrderByWithRelationInput | TreePictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreePictures.
     */
    cursor?: TreePictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreePictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreePictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreePictures.
     */
    distinct?: TreePictureScalarFieldEnum | TreePictureScalarFieldEnum[]
  }

  /**
   * TreePicture findMany
   */
  export type TreePictureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter, which TreePictures to fetch.
     */
    where?: TreePictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreePictures to fetch.
     */
    orderBy?: TreePictureOrderByWithRelationInput | TreePictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreePictures.
     */
    cursor?: TreePictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreePictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreePictures.
     */
    skip?: number
    distinct?: TreePictureScalarFieldEnum | TreePictureScalarFieldEnum[]
  }

  /**
   * TreePicture create
   */
  export type TreePictureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * The data needed to create a TreePicture.
     */
    data: XOR<TreePictureCreateInput, TreePictureUncheckedCreateInput>
  }

  /**
   * TreePicture createMany
   */
  export type TreePictureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreePictures.
     */
    data: TreePictureCreateManyInput | TreePictureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TreePicture createManyAndReturn
   */
  export type TreePictureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TreePictures.
     */
    data: TreePictureCreateManyInput | TreePictureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TreePicture update
   */
  export type TreePictureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * The data needed to update a TreePicture.
     */
    data: XOR<TreePictureUpdateInput, TreePictureUncheckedUpdateInput>
    /**
     * Choose, which TreePicture to update.
     */
    where: TreePictureWhereUniqueInput
  }

  /**
   * TreePicture updateMany
   */
  export type TreePictureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreePictures.
     */
    data: XOR<TreePictureUpdateManyMutationInput, TreePictureUncheckedUpdateManyInput>
    /**
     * Filter which TreePictures to update
     */
    where?: TreePictureWhereInput
  }

  /**
   * TreePicture upsert
   */
  export type TreePictureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * The filter to search for the TreePicture to update in case it exists.
     */
    where: TreePictureWhereUniqueInput
    /**
     * In case the TreePicture found by the `where` argument doesn't exist, create a new TreePicture with this data.
     */
    create: XOR<TreePictureCreateInput, TreePictureUncheckedCreateInput>
    /**
     * In case the TreePicture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreePictureUpdateInput, TreePictureUncheckedUpdateInput>
  }

  /**
   * TreePicture delete
   */
  export type TreePictureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
    /**
     * Filter which TreePicture to delete.
     */
    where: TreePictureWhereUniqueInput
  }

  /**
   * TreePicture deleteMany
   */
  export type TreePictureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreePictures to delete
     */
    where?: TreePictureWhereInput
  }

  /**
   * TreePicture without action
   */
  export type TreePictureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreePicture
     */
    select?: TreePictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreePictureInclude<ExtArgs> | null
  }


  /**
   * Model RoadPicture
   */

  export type AggregateRoadPicture = {
    _count: RoadPictureCountAggregateOutputType | null
    _min: RoadPictureMinAggregateOutputType | null
    _max: RoadPictureMaxAggregateOutputType | null
  }

  export type RoadPictureMinAggregateOutputType = {
    id: string | null
    url: string | null
    roadId: string | null
    uploaded: Date | null
  }

  export type RoadPictureMaxAggregateOutputType = {
    id: string | null
    url: string | null
    roadId: string | null
    uploaded: Date | null
  }

  export type RoadPictureCountAggregateOutputType = {
    id: number
    url: number
    roadId: number
    uploaded: number
    _all: number
  }


  export type RoadPictureMinAggregateInputType = {
    id?: true
    url?: true
    roadId?: true
    uploaded?: true
  }

  export type RoadPictureMaxAggregateInputType = {
    id?: true
    url?: true
    roadId?: true
    uploaded?: true
  }

  export type RoadPictureCountAggregateInputType = {
    id?: true
    url?: true
    roadId?: true
    uploaded?: true
    _all?: true
  }

  export type RoadPictureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadPicture to aggregate.
     */
    where?: RoadPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadPictures to fetch.
     */
    orderBy?: RoadPictureOrderByWithRelationInput | RoadPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadPictures
    **/
    _count?: true | RoadPictureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadPictureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadPictureMaxAggregateInputType
  }

  export type GetRoadPictureAggregateType<T extends RoadPictureAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadPicture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadPicture[P]>
      : GetScalarType<T[P], AggregateRoadPicture[P]>
  }




  export type RoadPictureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadPictureWhereInput
    orderBy?: RoadPictureOrderByWithAggregationInput | RoadPictureOrderByWithAggregationInput[]
    by: RoadPictureScalarFieldEnum[] | RoadPictureScalarFieldEnum
    having?: RoadPictureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadPictureCountAggregateInputType | true
    _min?: RoadPictureMinAggregateInputType
    _max?: RoadPictureMaxAggregateInputType
  }

  export type RoadPictureGroupByOutputType = {
    id: string
    url: string
    roadId: string
    uploaded: Date
    _count: RoadPictureCountAggregateOutputType | null
    _min: RoadPictureMinAggregateOutputType | null
    _max: RoadPictureMaxAggregateOutputType | null
  }

  type GetRoadPictureGroupByPayload<T extends RoadPictureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadPictureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadPictureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadPictureGroupByOutputType[P]>
            : GetScalarType<T[P], RoadPictureGroupByOutputType[P]>
        }
      >
    >


  export type RoadPictureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    roadId?: boolean
    uploaded?: boolean
    road?: boolean | RoadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadPicture"]>

  export type RoadPictureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    roadId?: boolean
    uploaded?: boolean
    road?: boolean | RoadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadPicture"]>

  export type RoadPictureSelectScalar = {
    id?: boolean
    url?: boolean
    roadId?: boolean
    uploaded?: boolean
  }

  export type RoadPictureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    road?: boolean | RoadDefaultArgs<ExtArgs>
  }
  export type RoadPictureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    road?: boolean | RoadDefaultArgs<ExtArgs>
  }

  export type $RoadPicturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadPicture"
    objects: {
      road: Prisma.$RoadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      roadId: string
      uploaded: Date
    }, ExtArgs["result"]["roadPicture"]>
    composites: {}
  }

  type RoadPictureGetPayload<S extends boolean | null | undefined | RoadPictureDefaultArgs> = $Result.GetResult<Prisma.$RoadPicturePayload, S>

  type RoadPictureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadPictureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadPictureCountAggregateInputType | true
    }

  export interface RoadPictureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadPicture'], meta: { name: 'RoadPicture' } }
    /**
     * Find zero or one RoadPicture that matches the filter.
     * @param {RoadPictureFindUniqueArgs} args - Arguments to find a RoadPicture
     * @example
     * // Get one RoadPicture
     * const roadPicture = await prisma.roadPicture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadPictureFindUniqueArgs>(args: SelectSubset<T, RoadPictureFindUniqueArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadPicture that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadPictureFindUniqueOrThrowArgs} args - Arguments to find a RoadPicture
     * @example
     * // Get one RoadPicture
     * const roadPicture = await prisma.roadPicture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadPictureFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadPictureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadPicture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureFindFirstArgs} args - Arguments to find a RoadPicture
     * @example
     * // Get one RoadPicture
     * const roadPicture = await prisma.roadPicture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadPictureFindFirstArgs>(args?: SelectSubset<T, RoadPictureFindFirstArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadPicture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureFindFirstOrThrowArgs} args - Arguments to find a RoadPicture
     * @example
     * // Get one RoadPicture
     * const roadPicture = await prisma.roadPicture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadPictureFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadPictureFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadPictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadPictures
     * const roadPictures = await prisma.roadPicture.findMany()
     * 
     * // Get first 10 RoadPictures
     * const roadPictures = await prisma.roadPicture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadPictureWithIdOnly = await prisma.roadPicture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadPictureFindManyArgs>(args?: SelectSubset<T, RoadPictureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadPicture.
     * @param {RoadPictureCreateArgs} args - Arguments to create a RoadPicture.
     * @example
     * // Create one RoadPicture
     * const RoadPicture = await prisma.roadPicture.create({
     *   data: {
     *     // ... data to create a RoadPicture
     *   }
     * })
     * 
     */
    create<T extends RoadPictureCreateArgs>(args: SelectSubset<T, RoadPictureCreateArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadPictures.
     * @param {RoadPictureCreateManyArgs} args - Arguments to create many RoadPictures.
     * @example
     * // Create many RoadPictures
     * const roadPicture = await prisma.roadPicture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadPictureCreateManyArgs>(args?: SelectSubset<T, RoadPictureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadPictures and returns the data saved in the database.
     * @param {RoadPictureCreateManyAndReturnArgs} args - Arguments to create many RoadPictures.
     * @example
     * // Create many RoadPictures
     * const roadPicture = await prisma.roadPicture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadPictures and only return the `id`
     * const roadPictureWithIdOnly = await prisma.roadPicture.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadPictureCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadPictureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadPicture.
     * @param {RoadPictureDeleteArgs} args - Arguments to delete one RoadPicture.
     * @example
     * // Delete one RoadPicture
     * const RoadPicture = await prisma.roadPicture.delete({
     *   where: {
     *     // ... filter to delete one RoadPicture
     *   }
     * })
     * 
     */
    delete<T extends RoadPictureDeleteArgs>(args: SelectSubset<T, RoadPictureDeleteArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadPicture.
     * @param {RoadPictureUpdateArgs} args - Arguments to update one RoadPicture.
     * @example
     * // Update one RoadPicture
     * const roadPicture = await prisma.roadPicture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadPictureUpdateArgs>(args: SelectSubset<T, RoadPictureUpdateArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadPictures.
     * @param {RoadPictureDeleteManyArgs} args - Arguments to filter RoadPictures to delete.
     * @example
     * // Delete a few RoadPictures
     * const { count } = await prisma.roadPicture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadPictureDeleteManyArgs>(args?: SelectSubset<T, RoadPictureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadPictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadPictures
     * const roadPicture = await prisma.roadPicture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadPictureUpdateManyArgs>(args: SelectSubset<T, RoadPictureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadPicture.
     * @param {RoadPictureUpsertArgs} args - Arguments to update or create a RoadPicture.
     * @example
     * // Update or create a RoadPicture
     * const roadPicture = await prisma.roadPicture.upsert({
     *   create: {
     *     // ... data to create a RoadPicture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadPicture we want to update
     *   }
     * })
     */
    upsert<T extends RoadPictureUpsertArgs>(args: SelectSubset<T, RoadPictureUpsertArgs<ExtArgs>>): Prisma__RoadPictureClient<$Result.GetResult<Prisma.$RoadPicturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadPictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureCountArgs} args - Arguments to filter RoadPictures to count.
     * @example
     * // Count the number of RoadPictures
     * const count = await prisma.roadPicture.count({
     *   where: {
     *     // ... the filter for the RoadPictures we want to count
     *   }
     * })
    **/
    count<T extends RoadPictureCountArgs>(
      args?: Subset<T, RoadPictureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadPictureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadPicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadPictureAggregateArgs>(args: Subset<T, RoadPictureAggregateArgs>): Prisma.PrismaPromise<GetRoadPictureAggregateType<T>>

    /**
     * Group by RoadPicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadPictureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadPictureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadPictureGroupByArgs['orderBy'] }
        : { orderBy?: RoadPictureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadPictureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadPictureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadPicture model
   */
  readonly fields: RoadPictureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadPicture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadPictureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    road<T extends RoadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadDefaultArgs<ExtArgs>>): Prisma__RoadClient<$Result.GetResult<Prisma.$RoadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadPicture model
   */ 
  interface RoadPictureFieldRefs {
    readonly id: FieldRef<"RoadPicture", 'String'>
    readonly url: FieldRef<"RoadPicture", 'String'>
    readonly roadId: FieldRef<"RoadPicture", 'String'>
    readonly uploaded: FieldRef<"RoadPicture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadPicture findUnique
   */
  export type RoadPictureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter, which RoadPicture to fetch.
     */
    where: RoadPictureWhereUniqueInput
  }

  /**
   * RoadPicture findUniqueOrThrow
   */
  export type RoadPictureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter, which RoadPicture to fetch.
     */
    where: RoadPictureWhereUniqueInput
  }

  /**
   * RoadPicture findFirst
   */
  export type RoadPictureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter, which RoadPicture to fetch.
     */
    where?: RoadPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadPictures to fetch.
     */
    orderBy?: RoadPictureOrderByWithRelationInput | RoadPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadPictures.
     */
    cursor?: RoadPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadPictures.
     */
    distinct?: RoadPictureScalarFieldEnum | RoadPictureScalarFieldEnum[]
  }

  /**
   * RoadPicture findFirstOrThrow
   */
  export type RoadPictureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter, which RoadPicture to fetch.
     */
    where?: RoadPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadPictures to fetch.
     */
    orderBy?: RoadPictureOrderByWithRelationInput | RoadPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadPictures.
     */
    cursor?: RoadPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadPictures.
     */
    distinct?: RoadPictureScalarFieldEnum | RoadPictureScalarFieldEnum[]
  }

  /**
   * RoadPicture findMany
   */
  export type RoadPictureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter, which RoadPictures to fetch.
     */
    where?: RoadPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadPictures to fetch.
     */
    orderBy?: RoadPictureOrderByWithRelationInput | RoadPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadPictures.
     */
    cursor?: RoadPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadPictures.
     */
    skip?: number
    distinct?: RoadPictureScalarFieldEnum | RoadPictureScalarFieldEnum[]
  }

  /**
   * RoadPicture create
   */
  export type RoadPictureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadPicture.
     */
    data: XOR<RoadPictureCreateInput, RoadPictureUncheckedCreateInput>
  }

  /**
   * RoadPicture createMany
   */
  export type RoadPictureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadPictures.
     */
    data: RoadPictureCreateManyInput | RoadPictureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadPicture createManyAndReturn
   */
  export type RoadPictureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadPictures.
     */
    data: RoadPictureCreateManyInput | RoadPictureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadPicture update
   */
  export type RoadPictureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadPicture.
     */
    data: XOR<RoadPictureUpdateInput, RoadPictureUncheckedUpdateInput>
    /**
     * Choose, which RoadPicture to update.
     */
    where: RoadPictureWhereUniqueInput
  }

  /**
   * RoadPicture updateMany
   */
  export type RoadPictureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadPictures.
     */
    data: XOR<RoadPictureUpdateManyMutationInput, RoadPictureUncheckedUpdateManyInput>
    /**
     * Filter which RoadPictures to update
     */
    where?: RoadPictureWhereInput
  }

  /**
   * RoadPicture upsert
   */
  export type RoadPictureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadPicture to update in case it exists.
     */
    where: RoadPictureWhereUniqueInput
    /**
     * In case the RoadPicture found by the `where` argument doesn't exist, create a new RoadPicture with this data.
     */
    create: XOR<RoadPictureCreateInput, RoadPictureUncheckedCreateInput>
    /**
     * In case the RoadPicture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadPictureUpdateInput, RoadPictureUncheckedUpdateInput>
  }

  /**
   * RoadPicture delete
   */
  export type RoadPictureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
    /**
     * Filter which RoadPicture to delete.
     */
    where: RoadPictureWhereUniqueInput
  }

  /**
   * RoadPicture deleteMany
   */
  export type RoadPictureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadPictures to delete
     */
    where?: RoadPictureWhereInput
  }

  /**
   * RoadPicture without action
   */
  export type RoadPictureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadPicture
     */
    select?: RoadPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadPictureInclude<ExtArgs> | null
  }


  /**
   * Model ReportPicture
   */

  export type AggregateReportPicture = {
    _count: ReportPictureCountAggregateOutputType | null
    _min: ReportPictureMinAggregateOutputType | null
    _max: ReportPictureMaxAggregateOutputType | null
  }

  export type ReportPictureMinAggregateOutputType = {
    id: string | null
    url: string | null
    reportId: string | null
    uploaded: Date | null
  }

  export type ReportPictureMaxAggregateOutputType = {
    id: string | null
    url: string | null
    reportId: string | null
    uploaded: Date | null
  }

  export type ReportPictureCountAggregateOutputType = {
    id: number
    url: number
    reportId: number
    uploaded: number
    _all: number
  }


  export type ReportPictureMinAggregateInputType = {
    id?: true
    url?: true
    reportId?: true
    uploaded?: true
  }

  export type ReportPictureMaxAggregateInputType = {
    id?: true
    url?: true
    reportId?: true
    uploaded?: true
  }

  export type ReportPictureCountAggregateInputType = {
    id?: true
    url?: true
    reportId?: true
    uploaded?: true
    _all?: true
  }

  export type ReportPictureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportPicture to aggregate.
     */
    where?: ReportPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPictures to fetch.
     */
    orderBy?: ReportPictureOrderByWithRelationInput | ReportPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportPictures
    **/
    _count?: true | ReportPictureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportPictureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportPictureMaxAggregateInputType
  }

  export type GetReportPictureAggregateType<T extends ReportPictureAggregateArgs> = {
        [P in keyof T & keyof AggregateReportPicture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportPicture[P]>
      : GetScalarType<T[P], AggregateReportPicture[P]>
  }




  export type ReportPictureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportPictureWhereInput
    orderBy?: ReportPictureOrderByWithAggregationInput | ReportPictureOrderByWithAggregationInput[]
    by: ReportPictureScalarFieldEnum[] | ReportPictureScalarFieldEnum
    having?: ReportPictureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportPictureCountAggregateInputType | true
    _min?: ReportPictureMinAggregateInputType
    _max?: ReportPictureMaxAggregateInputType
  }

  export type ReportPictureGroupByOutputType = {
    id: string
    url: string
    reportId: string
    uploaded: Date
    _count: ReportPictureCountAggregateOutputType | null
    _min: ReportPictureMinAggregateOutputType | null
    _max: ReportPictureMaxAggregateOutputType | null
  }

  type GetReportPictureGroupByPayload<T extends ReportPictureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportPictureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportPictureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportPictureGroupByOutputType[P]>
            : GetScalarType<T[P], ReportPictureGroupByOutputType[P]>
        }
      >
    >


  export type ReportPictureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    reportId?: boolean
    uploaded?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportPicture"]>

  export type ReportPictureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    reportId?: boolean
    uploaded?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportPicture"]>

  export type ReportPictureSelectScalar = {
    id?: boolean
    url?: boolean
    reportId?: boolean
    uploaded?: boolean
  }

  export type ReportPictureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportPictureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $ReportPicturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportPicture"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      reportId: string
      uploaded: Date
    }, ExtArgs["result"]["reportPicture"]>
    composites: {}
  }

  type ReportPictureGetPayload<S extends boolean | null | undefined | ReportPictureDefaultArgs> = $Result.GetResult<Prisma.$ReportPicturePayload, S>

  type ReportPictureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportPictureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportPictureCountAggregateInputType | true
    }

  export interface ReportPictureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportPicture'], meta: { name: 'ReportPicture' } }
    /**
     * Find zero or one ReportPicture that matches the filter.
     * @param {ReportPictureFindUniqueArgs} args - Arguments to find a ReportPicture
     * @example
     * // Get one ReportPicture
     * const reportPicture = await prisma.reportPicture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportPictureFindUniqueArgs>(args: SelectSubset<T, ReportPictureFindUniqueArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportPicture that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportPictureFindUniqueOrThrowArgs} args - Arguments to find a ReportPicture
     * @example
     * // Get one ReportPicture
     * const reportPicture = await prisma.reportPicture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportPictureFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportPictureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportPicture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureFindFirstArgs} args - Arguments to find a ReportPicture
     * @example
     * // Get one ReportPicture
     * const reportPicture = await prisma.reportPicture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportPictureFindFirstArgs>(args?: SelectSubset<T, ReportPictureFindFirstArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportPicture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureFindFirstOrThrowArgs} args - Arguments to find a ReportPicture
     * @example
     * // Get one ReportPicture
     * const reportPicture = await prisma.reportPicture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportPictureFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportPictureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportPictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportPictures
     * const reportPictures = await prisma.reportPicture.findMany()
     * 
     * // Get first 10 ReportPictures
     * const reportPictures = await prisma.reportPicture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportPictureWithIdOnly = await prisma.reportPicture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportPictureFindManyArgs>(args?: SelectSubset<T, ReportPictureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportPicture.
     * @param {ReportPictureCreateArgs} args - Arguments to create a ReportPicture.
     * @example
     * // Create one ReportPicture
     * const ReportPicture = await prisma.reportPicture.create({
     *   data: {
     *     // ... data to create a ReportPicture
     *   }
     * })
     * 
     */
    create<T extends ReportPictureCreateArgs>(args: SelectSubset<T, ReportPictureCreateArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportPictures.
     * @param {ReportPictureCreateManyArgs} args - Arguments to create many ReportPictures.
     * @example
     * // Create many ReportPictures
     * const reportPicture = await prisma.reportPicture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportPictureCreateManyArgs>(args?: SelectSubset<T, ReportPictureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportPictures and returns the data saved in the database.
     * @param {ReportPictureCreateManyAndReturnArgs} args - Arguments to create many ReportPictures.
     * @example
     * // Create many ReportPictures
     * const reportPicture = await prisma.reportPicture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportPictures and only return the `id`
     * const reportPictureWithIdOnly = await prisma.reportPicture.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportPictureCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportPictureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportPicture.
     * @param {ReportPictureDeleteArgs} args - Arguments to delete one ReportPicture.
     * @example
     * // Delete one ReportPicture
     * const ReportPicture = await prisma.reportPicture.delete({
     *   where: {
     *     // ... filter to delete one ReportPicture
     *   }
     * })
     * 
     */
    delete<T extends ReportPictureDeleteArgs>(args: SelectSubset<T, ReportPictureDeleteArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportPicture.
     * @param {ReportPictureUpdateArgs} args - Arguments to update one ReportPicture.
     * @example
     * // Update one ReportPicture
     * const reportPicture = await prisma.reportPicture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportPictureUpdateArgs>(args: SelectSubset<T, ReportPictureUpdateArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportPictures.
     * @param {ReportPictureDeleteManyArgs} args - Arguments to filter ReportPictures to delete.
     * @example
     * // Delete a few ReportPictures
     * const { count } = await prisma.reportPicture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportPictureDeleteManyArgs>(args?: SelectSubset<T, ReportPictureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportPictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportPictures
     * const reportPicture = await prisma.reportPicture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportPictureUpdateManyArgs>(args: SelectSubset<T, ReportPictureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportPicture.
     * @param {ReportPictureUpsertArgs} args - Arguments to update or create a ReportPicture.
     * @example
     * // Update or create a ReportPicture
     * const reportPicture = await prisma.reportPicture.upsert({
     *   create: {
     *     // ... data to create a ReportPicture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportPicture we want to update
     *   }
     * })
     */
    upsert<T extends ReportPictureUpsertArgs>(args: SelectSubset<T, ReportPictureUpsertArgs<ExtArgs>>): Prisma__ReportPictureClient<$Result.GetResult<Prisma.$ReportPicturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportPictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureCountArgs} args - Arguments to filter ReportPictures to count.
     * @example
     * // Count the number of ReportPictures
     * const count = await prisma.reportPicture.count({
     *   where: {
     *     // ... the filter for the ReportPictures we want to count
     *   }
     * })
    **/
    count<T extends ReportPictureCountArgs>(
      args?: Subset<T, ReportPictureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportPictureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportPicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportPictureAggregateArgs>(args: Subset<T, ReportPictureAggregateArgs>): Prisma.PrismaPromise<GetReportPictureAggregateType<T>>

    /**
     * Group by ReportPicture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPictureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportPictureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportPictureGroupByArgs['orderBy'] }
        : { orderBy?: ReportPictureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportPictureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportPictureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportPicture model
   */
  readonly fields: ReportPictureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportPicture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportPictureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportPicture model
   */ 
  interface ReportPictureFieldRefs {
    readonly id: FieldRef<"ReportPicture", 'String'>
    readonly url: FieldRef<"ReportPicture", 'String'>
    readonly reportId: FieldRef<"ReportPicture", 'String'>
    readonly uploaded: FieldRef<"ReportPicture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportPicture findUnique
   */
  export type ReportPictureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter, which ReportPicture to fetch.
     */
    where: ReportPictureWhereUniqueInput
  }

  /**
   * ReportPicture findUniqueOrThrow
   */
  export type ReportPictureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter, which ReportPicture to fetch.
     */
    where: ReportPictureWhereUniqueInput
  }

  /**
   * ReportPicture findFirst
   */
  export type ReportPictureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter, which ReportPicture to fetch.
     */
    where?: ReportPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPictures to fetch.
     */
    orderBy?: ReportPictureOrderByWithRelationInput | ReportPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPictures.
     */
    cursor?: ReportPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportPictures.
     */
    distinct?: ReportPictureScalarFieldEnum | ReportPictureScalarFieldEnum[]
  }

  /**
   * ReportPicture findFirstOrThrow
   */
  export type ReportPictureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter, which ReportPicture to fetch.
     */
    where?: ReportPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPictures to fetch.
     */
    orderBy?: ReportPictureOrderByWithRelationInput | ReportPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPictures.
     */
    cursor?: ReportPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPictures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportPictures.
     */
    distinct?: ReportPictureScalarFieldEnum | ReportPictureScalarFieldEnum[]
  }

  /**
   * ReportPicture findMany
   */
  export type ReportPictureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter, which ReportPictures to fetch.
     */
    where?: ReportPictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPictures to fetch.
     */
    orderBy?: ReportPictureOrderByWithRelationInput | ReportPictureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportPictures.
     */
    cursor?: ReportPictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPictures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPictures.
     */
    skip?: number
    distinct?: ReportPictureScalarFieldEnum | ReportPictureScalarFieldEnum[]
  }

  /**
   * ReportPicture create
   */
  export type ReportPictureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportPicture.
     */
    data: XOR<ReportPictureCreateInput, ReportPictureUncheckedCreateInput>
  }

  /**
   * ReportPicture createMany
   */
  export type ReportPictureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportPictures.
     */
    data: ReportPictureCreateManyInput | ReportPictureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportPicture createManyAndReturn
   */
  export type ReportPictureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportPictures.
     */
    data: ReportPictureCreateManyInput | ReportPictureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportPicture update
   */
  export type ReportPictureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportPicture.
     */
    data: XOR<ReportPictureUpdateInput, ReportPictureUncheckedUpdateInput>
    /**
     * Choose, which ReportPicture to update.
     */
    where: ReportPictureWhereUniqueInput
  }

  /**
   * ReportPicture updateMany
   */
  export type ReportPictureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportPictures.
     */
    data: XOR<ReportPictureUpdateManyMutationInput, ReportPictureUncheckedUpdateManyInput>
    /**
     * Filter which ReportPictures to update
     */
    where?: ReportPictureWhereInput
  }

  /**
   * ReportPicture upsert
   */
  export type ReportPictureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportPicture to update in case it exists.
     */
    where: ReportPictureWhereUniqueInput
    /**
     * In case the ReportPicture found by the `where` argument doesn't exist, create a new ReportPicture with this data.
     */
    create: XOR<ReportPictureCreateInput, ReportPictureUncheckedCreateInput>
    /**
     * In case the ReportPicture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportPictureUpdateInput, ReportPictureUncheckedUpdateInput>
  }

  /**
   * ReportPicture delete
   */
  export type ReportPictureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
    /**
     * Filter which ReportPicture to delete.
     */
    where: ReportPictureWhereUniqueInput
  }

  /**
   * ReportPicture deleteMany
   */
  export type ReportPictureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportPictures to delete
     */
    where?: ReportPictureWhereInput
  }

  /**
   * ReportPicture without action
   */
  export type ReportPictureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPicture
     */
    select?: ReportPictureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPictureInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    phone: 'phone',
    userpic: 'userpic',
    bio: 'bio',
    address: 'address',
    country: 'country',
    province: 'province',
    city: 'city',
    postalcode: 'postalcode',
    role: 'role',
    timestamp: 'timestamp'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TreeScalarFieldEnum: {
    id: 'id',
    latitude: 'latitude',
    longitude: 'longitude',
    species: 'species',
    age: 'age',
    trunk_diameter: 'trunk_diameter',
    lbranch_width: 'lbranch_width',
    ownership: 'ownership',
    description: 'description',
    roadName: 'roadName',
    status: 'status',
    timestamp: 'timestamp',
    roadId: 'roadId'
  };

  export type TreeScalarFieldEnum = (typeof TreeScalarFieldEnum)[keyof typeof TreeScalarFieldEnum]


  export const RoadScalarFieldEnum: {
    id: 'id',
    nameroad: 'nameroad',
    description: 'description',
    geometry: 'geometry',
    source_osm_id: 'source_osm_id',
    osm_type: 'osm_type',
    osm_tags: 'osm_tags',
    osm_properties: 'osm_properties',
    color: 'color',
    status: 'status'
  };

  export type RoadScalarFieldEnum = (typeof RoadScalarFieldEnum)[keyof typeof RoadScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    treeId: 'treeId',
    description: 'description',
    status: 'status',
    timestamp: 'timestamp',
    verifiedById: 'verifiedById',
    resolvedById: 'resolvedById',
    resolvedAt: 'resolvedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const TreePictureScalarFieldEnum: {
    id: 'id',
    url: 'url',
    treeId: 'treeId',
    uploaded: 'uploaded'
  };

  export type TreePictureScalarFieldEnum = (typeof TreePictureScalarFieldEnum)[keyof typeof TreePictureScalarFieldEnum]


  export const RoadPictureScalarFieldEnum: {
    id: 'id',
    url: 'url',
    roadId: 'roadId',
    uploaded: 'uploaded'
  };

  export type RoadPictureScalarFieldEnum = (typeof RoadPictureScalarFieldEnum)[keyof typeof RoadPictureScalarFieldEnum]


  export const ReportPictureScalarFieldEnum: {
    id: 'id',
    url: 'url',
    reportId: 'reportId',
    uploaded: 'uploaded'
  };

  export type ReportPictureScalarFieldEnum = (typeof ReportPictureScalarFieldEnum)[keyof typeof ReportPictureScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TreeStatus'
   */
  export type EnumTreeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreeStatus'>
    


  /**
   * Reference to a field of type 'TreeStatus[]'
   */
  export type ListEnumTreeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreeStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'RoadColor'
   */
  export type EnumRoadColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadColor'>
    


  /**
   * Reference to a field of type 'RoadColor[]'
   */
  export type ListEnumRoadColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadColor[]'>
    


  /**
   * Reference to a field of type 'RoadStatus'
   */
  export type EnumRoadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadStatus'>
    


  /**
   * Reference to a field of type 'RoadStatus[]'
   */
  export type ListEnumRoadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadStatus[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    userpic?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    province?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    postalcode?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    timestamp?: DateTimeFilter<"User"> | Date | string
    reports?: ReportListRelationFilter
    verified?: ReportListRelationFilter
    resolved?: ReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    userpic?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalcode?: SortOrderInput | SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    reports?: ReportOrderByRelationAggregateInput
    verified?: ReportOrderByRelationAggregateInput
    resolved?: ReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    userpic?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    province?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    postalcode?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    timestamp?: DateTimeFilter<"User"> | Date | string
    reports?: ReportListRelationFilter
    verified?: ReportListRelationFilter
    resolved?: ReportListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    userpic?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postalcode?: SortOrderInput | SortOrder
    role?: SortOrder
    timestamp?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstname?: StringWithAggregatesFilter<"User"> | string
    lastname?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    userpic?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    province?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    postalcode?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    timestamp?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type TreeWhereInput = {
    AND?: TreeWhereInput | TreeWhereInput[]
    OR?: TreeWhereInput[]
    NOT?: TreeWhereInput | TreeWhereInput[]
    id?: StringFilter<"Tree"> | string
    latitude?: FloatFilter<"Tree"> | number
    longitude?: FloatFilter<"Tree"> | number
    species?: StringNullableFilter<"Tree"> | string | null
    age?: IntNullableFilter<"Tree"> | number | null
    trunk_diameter?: FloatNullableFilter<"Tree"> | number | null
    lbranch_width?: FloatNullableFilter<"Tree"> | number | null
    ownership?: StringNullableFilter<"Tree"> | string | null
    description?: StringNullableFilter<"Tree"> | string | null
    roadName?: StringNullableFilter<"Tree"> | string | null
    status?: EnumTreeStatusFilter<"Tree"> | $Enums.TreeStatus
    timestamp?: DateTimeFilter<"Tree"> | Date | string
    roadId?: StringNullableFilter<"Tree"> | string | null
    road?: XOR<RoadNullableRelationFilter, RoadWhereInput> | null
    reports?: ReportListRelationFilter
    treePictures?: TreePictureListRelationFilter
  }

  export type TreeOrderByWithRelationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    species?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    trunk_diameter?: SortOrderInput | SortOrder
    lbranch_width?: SortOrderInput | SortOrder
    ownership?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    roadName?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    roadId?: SortOrderInput | SortOrder
    road?: RoadOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    treePictures?: TreePictureOrderByRelationAggregateInput
  }

  export type TreeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreeWhereInput | TreeWhereInput[]
    OR?: TreeWhereInput[]
    NOT?: TreeWhereInput | TreeWhereInput[]
    latitude?: FloatFilter<"Tree"> | number
    longitude?: FloatFilter<"Tree"> | number
    species?: StringNullableFilter<"Tree"> | string | null
    age?: IntNullableFilter<"Tree"> | number | null
    trunk_diameter?: FloatNullableFilter<"Tree"> | number | null
    lbranch_width?: FloatNullableFilter<"Tree"> | number | null
    ownership?: StringNullableFilter<"Tree"> | string | null
    description?: StringNullableFilter<"Tree"> | string | null
    roadName?: StringNullableFilter<"Tree"> | string | null
    status?: EnumTreeStatusFilter<"Tree"> | $Enums.TreeStatus
    timestamp?: DateTimeFilter<"Tree"> | Date | string
    roadId?: StringNullableFilter<"Tree"> | string | null
    road?: XOR<RoadNullableRelationFilter, RoadWhereInput> | null
    reports?: ReportListRelationFilter
    treePictures?: TreePictureListRelationFilter
  }, "id">

  export type TreeOrderByWithAggregationInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    species?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    trunk_diameter?: SortOrderInput | SortOrder
    lbranch_width?: SortOrderInput | SortOrder
    ownership?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    roadName?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    roadId?: SortOrderInput | SortOrder
    _count?: TreeCountOrderByAggregateInput
    _avg?: TreeAvgOrderByAggregateInput
    _max?: TreeMaxOrderByAggregateInput
    _min?: TreeMinOrderByAggregateInput
    _sum?: TreeSumOrderByAggregateInput
  }

  export type TreeScalarWhereWithAggregatesInput = {
    AND?: TreeScalarWhereWithAggregatesInput | TreeScalarWhereWithAggregatesInput[]
    OR?: TreeScalarWhereWithAggregatesInput[]
    NOT?: TreeScalarWhereWithAggregatesInput | TreeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tree"> | string
    latitude?: FloatWithAggregatesFilter<"Tree"> | number
    longitude?: FloatWithAggregatesFilter<"Tree"> | number
    species?: StringNullableWithAggregatesFilter<"Tree"> | string | null
    age?: IntNullableWithAggregatesFilter<"Tree"> | number | null
    trunk_diameter?: FloatNullableWithAggregatesFilter<"Tree"> | number | null
    lbranch_width?: FloatNullableWithAggregatesFilter<"Tree"> | number | null
    ownership?: StringNullableWithAggregatesFilter<"Tree"> | string | null
    description?: StringNullableWithAggregatesFilter<"Tree"> | string | null
    roadName?: StringNullableWithAggregatesFilter<"Tree"> | string | null
    status?: EnumTreeStatusWithAggregatesFilter<"Tree"> | $Enums.TreeStatus
    timestamp?: DateTimeWithAggregatesFilter<"Tree"> | Date | string
    roadId?: StringNullableWithAggregatesFilter<"Tree"> | string | null
  }

  export type RoadWhereInput = {
    AND?: RoadWhereInput | RoadWhereInput[]
    OR?: RoadWhereInput[]
    NOT?: RoadWhereInput | RoadWhereInput[]
    id?: StringFilter<"Road"> | string
    nameroad?: StringNullableFilter<"Road"> | string | null
    description?: StringNullableFilter<"Road"> | string | null
    geometry?: JsonNullableFilter<"Road">
    source_osm_id?: StringNullableFilter<"Road"> | string | null
    osm_type?: StringNullableFilter<"Road"> | string | null
    osm_tags?: JsonNullableFilter<"Road">
    osm_properties?: JsonNullableFilter<"Road">
    color?: EnumRoadColorNullableFilter<"Road"> | $Enums.RoadColor | null
    status?: EnumRoadStatusFilter<"Road"> | $Enums.RoadStatus
    roadPictures?: RoadPictureListRelationFilter
    trees?: TreeListRelationFilter
  }

  export type RoadOrderByWithRelationInput = {
    id?: SortOrder
    nameroad?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    geometry?: SortOrderInput | SortOrder
    source_osm_id?: SortOrderInput | SortOrder
    osm_type?: SortOrderInput | SortOrder
    osm_tags?: SortOrderInput | SortOrder
    osm_properties?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    status?: SortOrder
    roadPictures?: RoadPictureOrderByRelationAggregateInput
    trees?: TreeOrderByRelationAggregateInput
  }

  export type RoadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadWhereInput | RoadWhereInput[]
    OR?: RoadWhereInput[]
    NOT?: RoadWhereInput | RoadWhereInput[]
    nameroad?: StringNullableFilter<"Road"> | string | null
    description?: StringNullableFilter<"Road"> | string | null
    geometry?: JsonNullableFilter<"Road">
    source_osm_id?: StringNullableFilter<"Road"> | string | null
    osm_type?: StringNullableFilter<"Road"> | string | null
    osm_tags?: JsonNullableFilter<"Road">
    osm_properties?: JsonNullableFilter<"Road">
    color?: EnumRoadColorNullableFilter<"Road"> | $Enums.RoadColor | null
    status?: EnumRoadStatusFilter<"Road"> | $Enums.RoadStatus
    roadPictures?: RoadPictureListRelationFilter
    trees?: TreeListRelationFilter
  }, "id">

  export type RoadOrderByWithAggregationInput = {
    id?: SortOrder
    nameroad?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    geometry?: SortOrderInput | SortOrder
    source_osm_id?: SortOrderInput | SortOrder
    osm_type?: SortOrderInput | SortOrder
    osm_tags?: SortOrderInput | SortOrder
    osm_properties?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: RoadCountOrderByAggregateInput
    _max?: RoadMaxOrderByAggregateInput
    _min?: RoadMinOrderByAggregateInput
  }

  export type RoadScalarWhereWithAggregatesInput = {
    AND?: RoadScalarWhereWithAggregatesInput | RoadScalarWhereWithAggregatesInput[]
    OR?: RoadScalarWhereWithAggregatesInput[]
    NOT?: RoadScalarWhereWithAggregatesInput | RoadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Road"> | string
    nameroad?: StringNullableWithAggregatesFilter<"Road"> | string | null
    description?: StringNullableWithAggregatesFilter<"Road"> | string | null
    geometry?: JsonNullableWithAggregatesFilter<"Road">
    source_osm_id?: StringNullableWithAggregatesFilter<"Road"> | string | null
    osm_type?: StringNullableWithAggregatesFilter<"Road"> | string | null
    osm_tags?: JsonNullableWithAggregatesFilter<"Road">
    osm_properties?: JsonNullableWithAggregatesFilter<"Road">
    color?: EnumRoadColorNullableWithAggregatesFilter<"Road"> | $Enums.RoadColor | null
    status?: EnumRoadStatusWithAggregatesFilter<"Road"> | $Enums.RoadStatus
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringNullableFilter<"Report"> | string | null
    treeId?: StringNullableFilter<"Report"> | string | null
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    timestamp?: DateTimeFilter<"Report"> | Date | string
    verifiedById?: StringNullableFilter<"Report"> | string | null
    resolvedById?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tree?: XOR<TreeNullableRelationFilter, TreeWhereInput> | null
    verifiedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reportPictures?: ReportPictureListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    treeId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    tree?: TreeOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
    resolvedBy?: UserOrderByWithRelationInput
    reportPictures?: ReportPictureOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    userId?: StringNullableFilter<"Report"> | string | null
    treeId?: StringNullableFilter<"Report"> | string | null
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    timestamp?: DateTimeFilter<"Report"> | Date | string
    verifiedById?: StringNullableFilter<"Report"> | string | null
    resolvedById?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tree?: XOR<TreeNullableRelationFilter, TreeWhereInput> | null
    verifiedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reportPictures?: ReportPictureListRelationFilter
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    treeId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    userId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    treeId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    timestamp?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    verifiedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    resolvedById?: StringNullableWithAggregatesFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type TreePictureWhereInput = {
    AND?: TreePictureWhereInput | TreePictureWhereInput[]
    OR?: TreePictureWhereInput[]
    NOT?: TreePictureWhereInput | TreePictureWhereInput[]
    id?: StringFilter<"TreePicture"> | string
    url?: StringFilter<"TreePicture"> | string
    treeId?: StringFilter<"TreePicture"> | string
    uploaded?: DateTimeFilter<"TreePicture"> | Date | string
    tree?: XOR<TreeRelationFilter, TreeWhereInput>
  }

  export type TreePictureOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    treeId?: SortOrder
    uploaded?: SortOrder
    tree?: TreeOrderByWithRelationInput
  }

  export type TreePictureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreePictureWhereInput | TreePictureWhereInput[]
    OR?: TreePictureWhereInput[]
    NOT?: TreePictureWhereInput | TreePictureWhereInput[]
    url?: StringFilter<"TreePicture"> | string
    treeId?: StringFilter<"TreePicture"> | string
    uploaded?: DateTimeFilter<"TreePicture"> | Date | string
    tree?: XOR<TreeRelationFilter, TreeWhereInput>
  }, "id">

  export type TreePictureOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    treeId?: SortOrder
    uploaded?: SortOrder
    _count?: TreePictureCountOrderByAggregateInput
    _max?: TreePictureMaxOrderByAggregateInput
    _min?: TreePictureMinOrderByAggregateInput
  }

  export type TreePictureScalarWhereWithAggregatesInput = {
    AND?: TreePictureScalarWhereWithAggregatesInput | TreePictureScalarWhereWithAggregatesInput[]
    OR?: TreePictureScalarWhereWithAggregatesInput[]
    NOT?: TreePictureScalarWhereWithAggregatesInput | TreePictureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TreePicture"> | string
    url?: StringWithAggregatesFilter<"TreePicture"> | string
    treeId?: StringWithAggregatesFilter<"TreePicture"> | string
    uploaded?: DateTimeWithAggregatesFilter<"TreePicture"> | Date | string
  }

  export type RoadPictureWhereInput = {
    AND?: RoadPictureWhereInput | RoadPictureWhereInput[]
    OR?: RoadPictureWhereInput[]
    NOT?: RoadPictureWhereInput | RoadPictureWhereInput[]
    id?: StringFilter<"RoadPicture"> | string
    url?: StringFilter<"RoadPicture"> | string
    roadId?: StringFilter<"RoadPicture"> | string
    uploaded?: DateTimeFilter<"RoadPicture"> | Date | string
    road?: XOR<RoadRelationFilter, RoadWhereInput>
  }

  export type RoadPictureOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    roadId?: SortOrder
    uploaded?: SortOrder
    road?: RoadOrderByWithRelationInput
  }

  export type RoadPictureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadPictureWhereInput | RoadPictureWhereInput[]
    OR?: RoadPictureWhereInput[]
    NOT?: RoadPictureWhereInput | RoadPictureWhereInput[]
    url?: StringFilter<"RoadPicture"> | string
    roadId?: StringFilter<"RoadPicture"> | string
    uploaded?: DateTimeFilter<"RoadPicture"> | Date | string
    road?: XOR<RoadRelationFilter, RoadWhereInput>
  }, "id">

  export type RoadPictureOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    roadId?: SortOrder
    uploaded?: SortOrder
    _count?: RoadPictureCountOrderByAggregateInput
    _max?: RoadPictureMaxOrderByAggregateInput
    _min?: RoadPictureMinOrderByAggregateInput
  }

  export type RoadPictureScalarWhereWithAggregatesInput = {
    AND?: RoadPictureScalarWhereWithAggregatesInput | RoadPictureScalarWhereWithAggregatesInput[]
    OR?: RoadPictureScalarWhereWithAggregatesInput[]
    NOT?: RoadPictureScalarWhereWithAggregatesInput | RoadPictureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadPicture"> | string
    url?: StringWithAggregatesFilter<"RoadPicture"> | string
    roadId?: StringWithAggregatesFilter<"RoadPicture"> | string
    uploaded?: DateTimeWithAggregatesFilter<"RoadPicture"> | Date | string
  }

  export type ReportPictureWhereInput = {
    AND?: ReportPictureWhereInput | ReportPictureWhereInput[]
    OR?: ReportPictureWhereInput[]
    NOT?: ReportPictureWhereInput | ReportPictureWhereInput[]
    id?: StringFilter<"ReportPicture"> | string
    url?: StringFilter<"ReportPicture"> | string
    reportId?: StringFilter<"ReportPicture"> | string
    uploaded?: DateTimeFilter<"ReportPicture"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }

  export type ReportPictureOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    reportId?: SortOrder
    uploaded?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type ReportPictureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportPictureWhereInput | ReportPictureWhereInput[]
    OR?: ReportPictureWhereInput[]
    NOT?: ReportPictureWhereInput | ReportPictureWhereInput[]
    url?: StringFilter<"ReportPicture"> | string
    reportId?: StringFilter<"ReportPicture"> | string
    uploaded?: DateTimeFilter<"ReportPicture"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }, "id">

  export type ReportPictureOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    reportId?: SortOrder
    uploaded?: SortOrder
    _count?: ReportPictureCountOrderByAggregateInput
    _max?: ReportPictureMaxOrderByAggregateInput
    _min?: ReportPictureMinOrderByAggregateInput
  }

  export type ReportPictureScalarWhereWithAggregatesInput = {
    AND?: ReportPictureScalarWhereWithAggregatesInput | ReportPictureScalarWhereWithAggregatesInput[]
    OR?: ReportPictureScalarWhereWithAggregatesInput[]
    NOT?: ReportPictureScalarWhereWithAggregatesInput | ReportPictureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportPicture"> | string
    url?: StringWithAggregatesFilter<"ReportPicture"> | string
    reportId?: StringWithAggregatesFilter<"ReportPicture"> | string
    uploaded?: DateTimeWithAggregatesFilter<"ReportPicture"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportCreateNestedManyWithoutUserInput
    verified?: ReportCreateNestedManyWithoutVerifiedByInput
    resolved?: ReportCreateNestedManyWithoutResolvedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    verified?: ReportUncheckedCreateNestedManyWithoutVerifiedByInput
    resolved?: ReportUncheckedCreateNestedManyWithoutResolvedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutUserNestedInput
    verified?: ReportUpdateManyWithoutVerifiedByNestedInput
    resolved?: ReportUpdateManyWithoutResolvedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    verified?: ReportUncheckedUpdateManyWithoutVerifiedByNestedInput
    resolved?: ReportUncheckedUpdateManyWithoutResolvedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreeCreateInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    road?: RoadCreateNestedOneWithoutTreesInput
    reports?: ReportCreateNestedManyWithoutTreeInput
    treePictures?: TreePictureCreateNestedManyWithoutTreeInput
  }

  export type TreeUncheckedCreateInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    roadId?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutTreeInput
    treePictures?: TreePictureUncheckedCreateNestedManyWithoutTreeInput
  }

  export type TreeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    road?: RoadUpdateOneWithoutTreesNestedInput
    reports?: ReportUpdateManyWithoutTreeNestedInput
    treePictures?: TreePictureUpdateManyWithoutTreeNestedInput
  }

  export type TreeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roadId?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutTreeNestedInput
    treePictures?: TreePictureUncheckedUpdateManyWithoutTreeNestedInput
  }

  export type TreeCreateManyInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    roadId?: string | null
  }

  export type TreeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadCreateInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    roadPictures?: RoadPictureCreateNestedManyWithoutRoadInput
    trees?: TreeCreateNestedManyWithoutRoadInput
  }

  export type RoadUncheckedCreateInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    roadPictures?: RoadPictureUncheckedCreateNestedManyWithoutRoadInput
    trees?: TreeUncheckedCreateNestedManyWithoutRoadInput
  }

  export type RoadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    roadPictures?: RoadPictureUpdateManyWithoutRoadNestedInput
    trees?: TreeUpdateManyWithoutRoadNestedInput
  }

  export type RoadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    roadPictures?: RoadPictureUncheckedUpdateManyWithoutRoadNestedInput
    trees?: TreeUncheckedUpdateManyWithoutRoadNestedInput
  }

  export type RoadCreateManyInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
  }

  export type RoadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
  }

  export type RoadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
  }

  export type ReportCreateInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReportsInput
    tree?: TreeCreateNestedOneWithoutReportsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedInput
    reportPictures?: ReportPictureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    reportPictures?: ReportPictureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReportsNestedInput
    tree?: TreeUpdateOneWithoutReportsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedNestedInput
    reportPictures?: ReportPictureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportPictures?: ReportPictureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TreePictureCreateInput = {
    id?: string
    url: string
    uploaded?: Date | string
    tree: TreeCreateNestedOneWithoutTreePicturesInput
  }

  export type TreePictureUncheckedCreateInput = {
    id?: string
    url: string
    treeId: string
    uploaded?: Date | string
  }

  export type TreePictureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    tree?: TreeUpdateOneRequiredWithoutTreePicturesNestedInput
  }

  export type TreePictureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreePictureCreateManyInput = {
    id?: string
    url: string
    treeId: string
    uploaded?: Date | string
  }

  export type TreePictureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreePictureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureCreateInput = {
    id?: string
    url: string
    uploaded?: Date | string
    road: RoadCreateNestedOneWithoutRoadPicturesInput
  }

  export type RoadPictureUncheckedCreateInput = {
    id?: string
    url: string
    roadId: string
    uploaded?: Date | string
  }

  export type RoadPictureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    road?: RoadUpdateOneRequiredWithoutRoadPicturesNestedInput
  }

  export type RoadPictureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    roadId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureCreateManyInput = {
    id?: string
    url: string
    roadId: string
    uploaded?: Date | string
  }

  export type RoadPictureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    roadId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureCreateInput = {
    id?: string
    url: string
    uploaded?: Date | string
    report: ReportCreateNestedOneWithoutReportPicturesInput
  }

  export type ReportPictureUncheckedCreateInput = {
    id?: string
    url: string
    reportId: string
    uploaded?: Date | string
  }

  export type ReportPictureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutReportPicturesNestedInput
  }

  export type ReportPictureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureCreateManyInput = {
    id?: string
    url: string
    reportId: string
    uploaded?: Date | string
  }

  export type ReportPictureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    userpic?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    country?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    userpic?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    country?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    userpic?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    country?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postalcode?: SortOrder
    role?: SortOrder
    timestamp?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTreeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TreeStatus | EnumTreeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreeStatusFilter<$PrismaModel> | $Enums.TreeStatus
  }

  export type RoadNullableRelationFilter = {
    is?: RoadWhereInput | null
    isNot?: RoadWhereInput | null
  }

  export type TreePictureListRelationFilter = {
    every?: TreePictureWhereInput
    some?: TreePictureWhereInput
    none?: TreePictureWhereInput
  }

  export type TreePictureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreeCountOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    species?: SortOrder
    age?: SortOrder
    trunk_diameter?: SortOrder
    lbranch_width?: SortOrder
    ownership?: SortOrder
    description?: SortOrder
    roadName?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    roadId?: SortOrder
  }

  export type TreeAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    age?: SortOrder
    trunk_diameter?: SortOrder
    lbranch_width?: SortOrder
  }

  export type TreeMaxOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    species?: SortOrder
    age?: SortOrder
    trunk_diameter?: SortOrder
    lbranch_width?: SortOrder
    ownership?: SortOrder
    description?: SortOrder
    roadName?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    roadId?: SortOrder
  }

  export type TreeMinOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    species?: SortOrder
    age?: SortOrder
    trunk_diameter?: SortOrder
    lbranch_width?: SortOrder
    ownership?: SortOrder
    description?: SortOrder
    roadName?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    roadId?: SortOrder
  }

  export type TreeSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    age?: SortOrder
    trunk_diameter?: SortOrder
    lbranch_width?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTreeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreeStatus | EnumTreeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TreeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreeStatusFilter<$PrismaModel>
    _max?: NestedEnumTreeStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRoadColorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadColor | EnumRoadColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoadColorNullableFilter<$PrismaModel> | $Enums.RoadColor | null
  }

  export type EnumRoadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadStatus | EnumRoadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadStatusFilter<$PrismaModel> | $Enums.RoadStatus
  }

  export type RoadPictureListRelationFilter = {
    every?: RoadPictureWhereInput
    some?: RoadPictureWhereInput
    none?: RoadPictureWhereInput
  }

  export type TreeListRelationFilter = {
    every?: TreeWhereInput
    some?: TreeWhereInput
    none?: TreeWhereInput
  }

  export type RoadPictureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadCountOrderByAggregateInput = {
    id?: SortOrder
    nameroad?: SortOrder
    description?: SortOrder
    geometry?: SortOrder
    source_osm_id?: SortOrder
    osm_type?: SortOrder
    osm_tags?: SortOrder
    osm_properties?: SortOrder
    color?: SortOrder
    status?: SortOrder
  }

  export type RoadMaxOrderByAggregateInput = {
    id?: SortOrder
    nameroad?: SortOrder
    description?: SortOrder
    source_osm_id?: SortOrder
    osm_type?: SortOrder
    color?: SortOrder
    status?: SortOrder
  }

  export type RoadMinOrderByAggregateInput = {
    id?: SortOrder
    nameroad?: SortOrder
    description?: SortOrder
    source_osm_id?: SortOrder
    osm_type?: SortOrder
    color?: SortOrder
    status?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRoadColorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadColor | EnumRoadColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoadColorNullableWithAggregatesFilter<$PrismaModel> | $Enums.RoadColor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoadColorNullableFilter<$PrismaModel>
    _max?: NestedEnumRoadColorNullableFilter<$PrismaModel>
  }

  export type EnumRoadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadStatus | EnumRoadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoadStatusFilter<$PrismaModel>
    _max?: NestedEnumRoadStatusFilter<$PrismaModel>
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TreeNullableRelationFilter = {
    is?: TreeWhereInput | null
    isNot?: TreeWhereInput | null
  }

  export type ReportPictureListRelationFilter = {
    every?: ReportPictureWhereInput
    some?: ReportPictureWhereInput
    none?: ReportPictureWhereInput
  }

  export type ReportPictureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    treeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    verifiedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    treeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    verifiedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    treeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    verifiedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TreeRelationFilter = {
    is?: TreeWhereInput
    isNot?: TreeWhereInput
  }

  export type TreePictureCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    treeId?: SortOrder
    uploaded?: SortOrder
  }

  export type TreePictureMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    treeId?: SortOrder
    uploaded?: SortOrder
  }

  export type TreePictureMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    treeId?: SortOrder
    uploaded?: SortOrder
  }

  export type RoadRelationFilter = {
    is?: RoadWhereInput
    isNot?: RoadWhereInput
  }

  export type RoadPictureCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    roadId?: SortOrder
    uploaded?: SortOrder
  }

  export type RoadPictureMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    roadId?: SortOrder
    uploaded?: SortOrder
  }

  export type RoadPictureMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    roadId?: SortOrder
    uploaded?: SortOrder
  }

  export type ReportRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type ReportPictureCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    reportId?: SortOrder
    uploaded?: SortOrder
  }

  export type ReportPictureMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    reportId?: SortOrder
    uploaded?: SortOrder
  }

  export type ReportPictureMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    reportId?: SortOrder
    uploaded?: SortOrder
  }

  export type ReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput> | ReportCreateWithoutVerifiedByInput[] | ReportUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVerifiedByInput | ReportCreateOrConnectWithoutVerifiedByInput[]
    createMany?: ReportCreateManyVerifiedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput> | ReportCreateWithoutResolvedByInput[] | ReportUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolvedByInput | ReportCreateOrConnectWithoutResolvedByInput[]
    createMany?: ReportCreateManyResolvedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput> | ReportCreateWithoutVerifiedByInput[] | ReportUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVerifiedByInput | ReportCreateOrConnectWithoutVerifiedByInput[]
    createMany?: ReportCreateManyVerifiedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput> | ReportCreateWithoutResolvedByInput[] | ReportUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolvedByInput | ReportCreateOrConnectWithoutResolvedByInput[]
    createMany?: ReportCreateManyResolvedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput> | ReportCreateWithoutVerifiedByInput[] | ReportUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVerifiedByInput | ReportCreateOrConnectWithoutVerifiedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutVerifiedByInput | ReportUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: ReportCreateManyVerifiedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutVerifiedByInput | ReportUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutVerifiedByInput | ReportUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput> | ReportCreateWithoutResolvedByInput[] | ReportUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolvedByInput | ReportCreateOrConnectWithoutResolvedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutResolvedByInput | ReportUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: ReportCreateManyResolvedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutResolvedByInput | ReportUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutResolvedByInput | ReportUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput> | ReportCreateWithoutVerifiedByInput[] | ReportUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutVerifiedByInput | ReportCreateOrConnectWithoutVerifiedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutVerifiedByInput | ReportUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: ReportCreateManyVerifiedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutVerifiedByInput | ReportUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutVerifiedByInput | ReportUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput> | ReportCreateWithoutResolvedByInput[] | ReportUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutResolvedByInput | ReportCreateOrConnectWithoutResolvedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutResolvedByInput | ReportUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: ReportCreateManyResolvedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutResolvedByInput | ReportUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutResolvedByInput | ReportUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RoadCreateNestedOneWithoutTreesInput = {
    create?: XOR<RoadCreateWithoutTreesInput, RoadUncheckedCreateWithoutTreesInput>
    connectOrCreate?: RoadCreateOrConnectWithoutTreesInput
    connect?: RoadWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutTreeInput = {
    create?: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput> | ReportCreateWithoutTreeInput[] | ReportUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTreeInput | ReportCreateOrConnectWithoutTreeInput[]
    createMany?: ReportCreateManyTreeInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TreePictureCreateNestedManyWithoutTreeInput = {
    create?: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput> | TreePictureCreateWithoutTreeInput[] | TreePictureUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: TreePictureCreateOrConnectWithoutTreeInput | TreePictureCreateOrConnectWithoutTreeInput[]
    createMany?: TreePictureCreateManyTreeInputEnvelope
    connect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutTreeInput = {
    create?: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput> | ReportCreateWithoutTreeInput[] | ReportUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTreeInput | ReportCreateOrConnectWithoutTreeInput[]
    createMany?: ReportCreateManyTreeInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TreePictureUncheckedCreateNestedManyWithoutTreeInput = {
    create?: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput> | TreePictureCreateWithoutTreeInput[] | TreePictureUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: TreePictureCreateOrConnectWithoutTreeInput | TreePictureCreateOrConnectWithoutTreeInput[]
    createMany?: TreePictureCreateManyTreeInputEnvelope
    connect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTreeStatusFieldUpdateOperationsInput = {
    set?: $Enums.TreeStatus
  }

  export type RoadUpdateOneWithoutTreesNestedInput = {
    create?: XOR<RoadCreateWithoutTreesInput, RoadUncheckedCreateWithoutTreesInput>
    connectOrCreate?: RoadCreateOrConnectWithoutTreesInput
    upsert?: RoadUpsertWithoutTreesInput
    disconnect?: RoadWhereInput | boolean
    delete?: RoadWhereInput | boolean
    connect?: RoadWhereUniqueInput
    update?: XOR<XOR<RoadUpdateToOneWithWhereWithoutTreesInput, RoadUpdateWithoutTreesInput>, RoadUncheckedUpdateWithoutTreesInput>
  }

  export type ReportUpdateManyWithoutTreeNestedInput = {
    create?: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput> | ReportCreateWithoutTreeInput[] | ReportUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTreeInput | ReportCreateOrConnectWithoutTreeInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTreeInput | ReportUpsertWithWhereUniqueWithoutTreeInput[]
    createMany?: ReportCreateManyTreeInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTreeInput | ReportUpdateWithWhereUniqueWithoutTreeInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTreeInput | ReportUpdateManyWithWhereWithoutTreeInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TreePictureUpdateManyWithoutTreeNestedInput = {
    create?: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput> | TreePictureCreateWithoutTreeInput[] | TreePictureUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: TreePictureCreateOrConnectWithoutTreeInput | TreePictureCreateOrConnectWithoutTreeInput[]
    upsert?: TreePictureUpsertWithWhereUniqueWithoutTreeInput | TreePictureUpsertWithWhereUniqueWithoutTreeInput[]
    createMany?: TreePictureCreateManyTreeInputEnvelope
    set?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    disconnect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    delete?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    connect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    update?: TreePictureUpdateWithWhereUniqueWithoutTreeInput | TreePictureUpdateWithWhereUniqueWithoutTreeInput[]
    updateMany?: TreePictureUpdateManyWithWhereWithoutTreeInput | TreePictureUpdateManyWithWhereWithoutTreeInput[]
    deleteMany?: TreePictureScalarWhereInput | TreePictureScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutTreeNestedInput = {
    create?: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput> | ReportCreateWithoutTreeInput[] | ReportUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTreeInput | ReportCreateOrConnectWithoutTreeInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTreeInput | ReportUpsertWithWhereUniqueWithoutTreeInput[]
    createMany?: ReportCreateManyTreeInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTreeInput | ReportUpdateWithWhereUniqueWithoutTreeInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTreeInput | ReportUpdateManyWithWhereWithoutTreeInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TreePictureUncheckedUpdateManyWithoutTreeNestedInput = {
    create?: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput> | TreePictureCreateWithoutTreeInput[] | TreePictureUncheckedCreateWithoutTreeInput[]
    connectOrCreate?: TreePictureCreateOrConnectWithoutTreeInput | TreePictureCreateOrConnectWithoutTreeInput[]
    upsert?: TreePictureUpsertWithWhereUniqueWithoutTreeInput | TreePictureUpsertWithWhereUniqueWithoutTreeInput[]
    createMany?: TreePictureCreateManyTreeInputEnvelope
    set?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    disconnect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    delete?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    connect?: TreePictureWhereUniqueInput | TreePictureWhereUniqueInput[]
    update?: TreePictureUpdateWithWhereUniqueWithoutTreeInput | TreePictureUpdateWithWhereUniqueWithoutTreeInput[]
    updateMany?: TreePictureUpdateManyWithWhereWithoutTreeInput | TreePictureUpdateManyWithWhereWithoutTreeInput[]
    deleteMany?: TreePictureScalarWhereInput | TreePictureScalarWhereInput[]
  }

  export type RoadPictureCreateNestedManyWithoutRoadInput = {
    create?: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput> | RoadPictureCreateWithoutRoadInput[] | RoadPictureUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: RoadPictureCreateOrConnectWithoutRoadInput | RoadPictureCreateOrConnectWithoutRoadInput[]
    createMany?: RoadPictureCreateManyRoadInputEnvelope
    connect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
  }

  export type TreeCreateNestedManyWithoutRoadInput = {
    create?: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput> | TreeCreateWithoutRoadInput[] | TreeUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: TreeCreateOrConnectWithoutRoadInput | TreeCreateOrConnectWithoutRoadInput[]
    createMany?: TreeCreateManyRoadInputEnvelope
    connect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
  }

  export type RoadPictureUncheckedCreateNestedManyWithoutRoadInput = {
    create?: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput> | RoadPictureCreateWithoutRoadInput[] | RoadPictureUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: RoadPictureCreateOrConnectWithoutRoadInput | RoadPictureCreateOrConnectWithoutRoadInput[]
    createMany?: RoadPictureCreateManyRoadInputEnvelope
    connect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
  }

  export type TreeUncheckedCreateNestedManyWithoutRoadInput = {
    create?: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput> | TreeCreateWithoutRoadInput[] | TreeUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: TreeCreateOrConnectWithoutRoadInput | TreeCreateOrConnectWithoutRoadInput[]
    createMany?: TreeCreateManyRoadInputEnvelope
    connect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
  }

  export type NullableEnumRoadColorFieldUpdateOperationsInput = {
    set?: $Enums.RoadColor | null
  }

  export type EnumRoadStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoadStatus
  }

  export type RoadPictureUpdateManyWithoutRoadNestedInput = {
    create?: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput> | RoadPictureCreateWithoutRoadInput[] | RoadPictureUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: RoadPictureCreateOrConnectWithoutRoadInput | RoadPictureCreateOrConnectWithoutRoadInput[]
    upsert?: RoadPictureUpsertWithWhereUniqueWithoutRoadInput | RoadPictureUpsertWithWhereUniqueWithoutRoadInput[]
    createMany?: RoadPictureCreateManyRoadInputEnvelope
    set?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    disconnect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    delete?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    connect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    update?: RoadPictureUpdateWithWhereUniqueWithoutRoadInput | RoadPictureUpdateWithWhereUniqueWithoutRoadInput[]
    updateMany?: RoadPictureUpdateManyWithWhereWithoutRoadInput | RoadPictureUpdateManyWithWhereWithoutRoadInput[]
    deleteMany?: RoadPictureScalarWhereInput | RoadPictureScalarWhereInput[]
  }

  export type TreeUpdateManyWithoutRoadNestedInput = {
    create?: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput> | TreeCreateWithoutRoadInput[] | TreeUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: TreeCreateOrConnectWithoutRoadInput | TreeCreateOrConnectWithoutRoadInput[]
    upsert?: TreeUpsertWithWhereUniqueWithoutRoadInput | TreeUpsertWithWhereUniqueWithoutRoadInput[]
    createMany?: TreeCreateManyRoadInputEnvelope
    set?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    disconnect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    delete?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    connect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    update?: TreeUpdateWithWhereUniqueWithoutRoadInput | TreeUpdateWithWhereUniqueWithoutRoadInput[]
    updateMany?: TreeUpdateManyWithWhereWithoutRoadInput | TreeUpdateManyWithWhereWithoutRoadInput[]
    deleteMany?: TreeScalarWhereInput | TreeScalarWhereInput[]
  }

  export type RoadPictureUncheckedUpdateManyWithoutRoadNestedInput = {
    create?: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput> | RoadPictureCreateWithoutRoadInput[] | RoadPictureUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: RoadPictureCreateOrConnectWithoutRoadInput | RoadPictureCreateOrConnectWithoutRoadInput[]
    upsert?: RoadPictureUpsertWithWhereUniqueWithoutRoadInput | RoadPictureUpsertWithWhereUniqueWithoutRoadInput[]
    createMany?: RoadPictureCreateManyRoadInputEnvelope
    set?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    disconnect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    delete?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    connect?: RoadPictureWhereUniqueInput | RoadPictureWhereUniqueInput[]
    update?: RoadPictureUpdateWithWhereUniqueWithoutRoadInput | RoadPictureUpdateWithWhereUniqueWithoutRoadInput[]
    updateMany?: RoadPictureUpdateManyWithWhereWithoutRoadInput | RoadPictureUpdateManyWithWhereWithoutRoadInput[]
    deleteMany?: RoadPictureScalarWhereInput | RoadPictureScalarWhereInput[]
  }

  export type TreeUncheckedUpdateManyWithoutRoadNestedInput = {
    create?: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput> | TreeCreateWithoutRoadInput[] | TreeUncheckedCreateWithoutRoadInput[]
    connectOrCreate?: TreeCreateOrConnectWithoutRoadInput | TreeCreateOrConnectWithoutRoadInput[]
    upsert?: TreeUpsertWithWhereUniqueWithoutRoadInput | TreeUpsertWithWhereUniqueWithoutRoadInput[]
    createMany?: TreeCreateManyRoadInputEnvelope
    set?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    disconnect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    delete?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    connect?: TreeWhereUniqueInput | TreeWhereUniqueInput[]
    update?: TreeUpdateWithWhereUniqueWithoutRoadInput | TreeUpdateWithWhereUniqueWithoutRoadInput[]
    updateMany?: TreeUpdateManyWithWhereWithoutRoadInput | TreeUpdateManyWithWhereWithoutRoadInput[]
    deleteMany?: TreeScalarWhereInput | TreeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type TreeCreateNestedOneWithoutReportsInput = {
    create?: XOR<TreeCreateWithoutReportsInput, TreeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TreeCreateOrConnectWithoutReportsInput
    connect?: TreeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedInput = {
    create?: XOR<UserCreateWithoutVerifiedInput, UserUncheckedCreateWithoutVerifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResolvedInput = {
    create?: XOR<UserCreateWithoutResolvedInput, UserUncheckedCreateWithoutResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type ReportPictureCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput> | ReportPictureCreateWithoutReportInput[] | ReportPictureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPictureCreateOrConnectWithoutReportInput | ReportPictureCreateOrConnectWithoutReportInput[]
    createMany?: ReportPictureCreateManyReportInputEnvelope
    connect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
  }

  export type ReportPictureUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput> | ReportPictureCreateWithoutReportInput[] | ReportPictureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPictureCreateOrConnectWithoutReportInput | ReportPictureCreateOrConnectWithoutReportInput[]
    createMany?: ReportPictureCreateManyReportInputEnvelope
    connect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type TreeUpdateOneWithoutReportsNestedInput = {
    create?: XOR<TreeCreateWithoutReportsInput, TreeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TreeCreateOrConnectWithoutReportsInput
    upsert?: TreeUpsertWithoutReportsInput
    disconnect?: TreeWhereInput | boolean
    delete?: TreeWhereInput | boolean
    connect?: TreeWhereUniqueInput
    update?: XOR<XOR<TreeUpdateToOneWithWhereWithoutReportsInput, TreeUpdateWithoutReportsInput>, TreeUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneWithoutVerifiedNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedInput, UserUncheckedCreateWithoutVerifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedInput
    upsert?: UserUpsertWithoutVerifiedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedInput, UserUpdateWithoutVerifiedInput>, UserUncheckedUpdateWithoutVerifiedInput>
  }

  export type UserUpdateOneWithoutResolvedNestedInput = {
    create?: XOR<UserCreateWithoutResolvedInput, UserUncheckedCreateWithoutResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedInput
    upsert?: UserUpsertWithoutResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedInput, UserUpdateWithoutResolvedInput>, UserUncheckedUpdateWithoutResolvedInput>
  }

  export type ReportPictureUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput> | ReportPictureCreateWithoutReportInput[] | ReportPictureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPictureCreateOrConnectWithoutReportInput | ReportPictureCreateOrConnectWithoutReportInput[]
    upsert?: ReportPictureUpsertWithWhereUniqueWithoutReportInput | ReportPictureUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportPictureCreateManyReportInputEnvelope
    set?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    disconnect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    delete?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    connect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    update?: ReportPictureUpdateWithWhereUniqueWithoutReportInput | ReportPictureUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportPictureUpdateManyWithWhereWithoutReportInput | ReportPictureUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportPictureScalarWhereInput | ReportPictureScalarWhereInput[]
  }

  export type ReportPictureUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput> | ReportPictureCreateWithoutReportInput[] | ReportPictureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPictureCreateOrConnectWithoutReportInput | ReportPictureCreateOrConnectWithoutReportInput[]
    upsert?: ReportPictureUpsertWithWhereUniqueWithoutReportInput | ReportPictureUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportPictureCreateManyReportInputEnvelope
    set?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    disconnect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    delete?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    connect?: ReportPictureWhereUniqueInput | ReportPictureWhereUniqueInput[]
    update?: ReportPictureUpdateWithWhereUniqueWithoutReportInput | ReportPictureUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportPictureUpdateManyWithWhereWithoutReportInput | ReportPictureUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportPictureScalarWhereInput | ReportPictureScalarWhereInput[]
  }

  export type TreeCreateNestedOneWithoutTreePicturesInput = {
    create?: XOR<TreeCreateWithoutTreePicturesInput, TreeUncheckedCreateWithoutTreePicturesInput>
    connectOrCreate?: TreeCreateOrConnectWithoutTreePicturesInput
    connect?: TreeWhereUniqueInput
  }

  export type TreeUpdateOneRequiredWithoutTreePicturesNestedInput = {
    create?: XOR<TreeCreateWithoutTreePicturesInput, TreeUncheckedCreateWithoutTreePicturesInput>
    connectOrCreate?: TreeCreateOrConnectWithoutTreePicturesInput
    upsert?: TreeUpsertWithoutTreePicturesInput
    connect?: TreeWhereUniqueInput
    update?: XOR<XOR<TreeUpdateToOneWithWhereWithoutTreePicturesInput, TreeUpdateWithoutTreePicturesInput>, TreeUncheckedUpdateWithoutTreePicturesInput>
  }

  export type RoadCreateNestedOneWithoutRoadPicturesInput = {
    create?: XOR<RoadCreateWithoutRoadPicturesInput, RoadUncheckedCreateWithoutRoadPicturesInput>
    connectOrCreate?: RoadCreateOrConnectWithoutRoadPicturesInput
    connect?: RoadWhereUniqueInput
  }

  export type RoadUpdateOneRequiredWithoutRoadPicturesNestedInput = {
    create?: XOR<RoadCreateWithoutRoadPicturesInput, RoadUncheckedCreateWithoutRoadPicturesInput>
    connectOrCreate?: RoadCreateOrConnectWithoutRoadPicturesInput
    upsert?: RoadUpsertWithoutRoadPicturesInput
    connect?: RoadWhereUniqueInput
    update?: XOR<XOR<RoadUpdateToOneWithWhereWithoutRoadPicturesInput, RoadUpdateWithoutRoadPicturesInput>, RoadUncheckedUpdateWithoutRoadPicturesInput>
  }

  export type ReportCreateNestedOneWithoutReportPicturesInput = {
    create?: XOR<ReportCreateWithoutReportPicturesInput, ReportUncheckedCreateWithoutReportPicturesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportPicturesInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportUpdateOneRequiredWithoutReportPicturesNestedInput = {
    create?: XOR<ReportCreateWithoutReportPicturesInput, ReportUncheckedCreateWithoutReportPicturesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportPicturesInput
    upsert?: ReportUpsertWithoutReportPicturesInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutReportPicturesInput, ReportUpdateWithoutReportPicturesInput>, ReportUncheckedUpdateWithoutReportPicturesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTreeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TreeStatus | EnumTreeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreeStatusFilter<$PrismaModel> | $Enums.TreeStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTreeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreeStatus | EnumTreeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreeStatus[] | ListEnumTreeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTreeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TreeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreeStatusFilter<$PrismaModel>
    _max?: NestedEnumTreeStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoadColorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadColor | EnumRoadColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoadColorNullableFilter<$PrismaModel> | $Enums.RoadColor | null
  }

  export type NestedEnumRoadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadStatus | EnumRoadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadStatusFilter<$PrismaModel> | $Enums.RoadStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoadColorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadColor | EnumRoadColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RoadColor[] | ListEnumRoadColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoadColorNullableWithAggregatesFilter<$PrismaModel> | $Enums.RoadColor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoadColorNullableFilter<$PrismaModel>
    _max?: NestedEnumRoadColorNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadStatus | EnumRoadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadStatus[] | ListEnumRoadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoadStatusFilter<$PrismaModel>
    _max?: NestedEnumRoadStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ReportCreateWithoutUserInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    tree?: TreeCreateNestedOneWithoutReportsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedInput
    reportPictures?: ReportPictureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutUserInput = {
    id?: string
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    reportPictures?: ReportPictureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutVerifiedByInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReportsInput
    tree?: TreeCreateNestedOneWithoutReportsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedInput
    reportPictures?: ReportPictureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    reportPictures?: ReportPictureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutVerifiedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput>
  }

  export type ReportCreateManyVerifiedByInputEnvelope = {
    data: ReportCreateManyVerifiedByInput | ReportCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutResolvedByInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReportsInput
    tree?: TreeCreateNestedOneWithoutReportsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedInput
    reportPictures?: ReportPictureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutResolvedByInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedAt?: Date | string | null
    reportPictures?: ReportPictureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutResolvedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput>
  }

  export type ReportCreateManyResolvedByInputEnvelope = {
    data: ReportCreateManyResolvedByInput | ReportCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringNullableFilter<"Report"> | string | null
    treeId?: StringNullableFilter<"Report"> | string | null
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    timestamp?: DateTimeFilter<"Report"> | Date | string
    verifiedById?: StringNullableFilter<"Report"> | string | null
    resolvedById?: StringNullableFilter<"Report"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutVerifiedByInput, ReportUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<ReportCreateWithoutVerifiedByInput, ReportUncheckedCreateWithoutVerifiedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutVerifiedByInput, ReportUncheckedUpdateWithoutVerifiedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutVerifiedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutResolvedByInput, ReportUncheckedUpdateWithoutResolvedByInput>
    create: XOR<ReportCreateWithoutResolvedByInput, ReportUncheckedCreateWithoutResolvedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutResolvedByInput, ReportUncheckedUpdateWithoutResolvedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutResolvedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type RoadCreateWithoutTreesInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    roadPictures?: RoadPictureCreateNestedManyWithoutRoadInput
  }

  export type RoadUncheckedCreateWithoutTreesInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    roadPictures?: RoadPictureUncheckedCreateNestedManyWithoutRoadInput
  }

  export type RoadCreateOrConnectWithoutTreesInput = {
    where: RoadWhereUniqueInput
    create: XOR<RoadCreateWithoutTreesInput, RoadUncheckedCreateWithoutTreesInput>
  }

  export type ReportCreateWithoutTreeInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReportsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedInput
    reportPictures?: ReportPictureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutTreeInput = {
    id?: string
    userId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    reportPictures?: ReportPictureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutTreeInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput>
  }

  export type ReportCreateManyTreeInputEnvelope = {
    data: ReportCreateManyTreeInput | ReportCreateManyTreeInput[]
    skipDuplicates?: boolean
  }

  export type TreePictureCreateWithoutTreeInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type TreePictureUncheckedCreateWithoutTreeInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type TreePictureCreateOrConnectWithoutTreeInput = {
    where: TreePictureWhereUniqueInput
    create: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput>
  }

  export type TreePictureCreateManyTreeInputEnvelope = {
    data: TreePictureCreateManyTreeInput | TreePictureCreateManyTreeInput[]
    skipDuplicates?: boolean
  }

  export type RoadUpsertWithoutTreesInput = {
    update: XOR<RoadUpdateWithoutTreesInput, RoadUncheckedUpdateWithoutTreesInput>
    create: XOR<RoadCreateWithoutTreesInput, RoadUncheckedCreateWithoutTreesInput>
    where?: RoadWhereInput
  }

  export type RoadUpdateToOneWithWhereWithoutTreesInput = {
    where?: RoadWhereInput
    data: XOR<RoadUpdateWithoutTreesInput, RoadUncheckedUpdateWithoutTreesInput>
  }

  export type RoadUpdateWithoutTreesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    roadPictures?: RoadPictureUpdateManyWithoutRoadNestedInput
  }

  export type RoadUncheckedUpdateWithoutTreesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    roadPictures?: RoadPictureUncheckedUpdateManyWithoutRoadNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutTreeInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutTreeInput, ReportUncheckedUpdateWithoutTreeInput>
    create: XOR<ReportCreateWithoutTreeInput, ReportUncheckedCreateWithoutTreeInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutTreeInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutTreeInput, ReportUncheckedUpdateWithoutTreeInput>
  }

  export type ReportUpdateManyWithWhereWithoutTreeInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutTreeInput>
  }

  export type TreePictureUpsertWithWhereUniqueWithoutTreeInput = {
    where: TreePictureWhereUniqueInput
    update: XOR<TreePictureUpdateWithoutTreeInput, TreePictureUncheckedUpdateWithoutTreeInput>
    create: XOR<TreePictureCreateWithoutTreeInput, TreePictureUncheckedCreateWithoutTreeInput>
  }

  export type TreePictureUpdateWithWhereUniqueWithoutTreeInput = {
    where: TreePictureWhereUniqueInput
    data: XOR<TreePictureUpdateWithoutTreeInput, TreePictureUncheckedUpdateWithoutTreeInput>
  }

  export type TreePictureUpdateManyWithWhereWithoutTreeInput = {
    where: TreePictureScalarWhereInput
    data: XOR<TreePictureUpdateManyMutationInput, TreePictureUncheckedUpdateManyWithoutTreeInput>
  }

  export type TreePictureScalarWhereInput = {
    AND?: TreePictureScalarWhereInput | TreePictureScalarWhereInput[]
    OR?: TreePictureScalarWhereInput[]
    NOT?: TreePictureScalarWhereInput | TreePictureScalarWhereInput[]
    id?: StringFilter<"TreePicture"> | string
    url?: StringFilter<"TreePicture"> | string
    treeId?: StringFilter<"TreePicture"> | string
    uploaded?: DateTimeFilter<"TreePicture"> | Date | string
  }

  export type RoadPictureCreateWithoutRoadInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type RoadPictureUncheckedCreateWithoutRoadInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type RoadPictureCreateOrConnectWithoutRoadInput = {
    where: RoadPictureWhereUniqueInput
    create: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput>
  }

  export type RoadPictureCreateManyRoadInputEnvelope = {
    data: RoadPictureCreateManyRoadInput | RoadPictureCreateManyRoadInput[]
    skipDuplicates?: boolean
  }

  export type TreeCreateWithoutRoadInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    reports?: ReportCreateNestedManyWithoutTreeInput
    treePictures?: TreePictureCreateNestedManyWithoutTreeInput
  }

  export type TreeUncheckedCreateWithoutRoadInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTreeInput
    treePictures?: TreePictureUncheckedCreateNestedManyWithoutTreeInput
  }

  export type TreeCreateOrConnectWithoutRoadInput = {
    where: TreeWhereUniqueInput
    create: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput>
  }

  export type TreeCreateManyRoadInputEnvelope = {
    data: TreeCreateManyRoadInput | TreeCreateManyRoadInput[]
    skipDuplicates?: boolean
  }

  export type RoadPictureUpsertWithWhereUniqueWithoutRoadInput = {
    where: RoadPictureWhereUniqueInput
    update: XOR<RoadPictureUpdateWithoutRoadInput, RoadPictureUncheckedUpdateWithoutRoadInput>
    create: XOR<RoadPictureCreateWithoutRoadInput, RoadPictureUncheckedCreateWithoutRoadInput>
  }

  export type RoadPictureUpdateWithWhereUniqueWithoutRoadInput = {
    where: RoadPictureWhereUniqueInput
    data: XOR<RoadPictureUpdateWithoutRoadInput, RoadPictureUncheckedUpdateWithoutRoadInput>
  }

  export type RoadPictureUpdateManyWithWhereWithoutRoadInput = {
    where: RoadPictureScalarWhereInput
    data: XOR<RoadPictureUpdateManyMutationInput, RoadPictureUncheckedUpdateManyWithoutRoadInput>
  }

  export type RoadPictureScalarWhereInput = {
    AND?: RoadPictureScalarWhereInput | RoadPictureScalarWhereInput[]
    OR?: RoadPictureScalarWhereInput[]
    NOT?: RoadPictureScalarWhereInput | RoadPictureScalarWhereInput[]
    id?: StringFilter<"RoadPicture"> | string
    url?: StringFilter<"RoadPicture"> | string
    roadId?: StringFilter<"RoadPicture"> | string
    uploaded?: DateTimeFilter<"RoadPicture"> | Date | string
  }

  export type TreeUpsertWithWhereUniqueWithoutRoadInput = {
    where: TreeWhereUniqueInput
    update: XOR<TreeUpdateWithoutRoadInput, TreeUncheckedUpdateWithoutRoadInput>
    create: XOR<TreeCreateWithoutRoadInput, TreeUncheckedCreateWithoutRoadInput>
  }

  export type TreeUpdateWithWhereUniqueWithoutRoadInput = {
    where: TreeWhereUniqueInput
    data: XOR<TreeUpdateWithoutRoadInput, TreeUncheckedUpdateWithoutRoadInput>
  }

  export type TreeUpdateManyWithWhereWithoutRoadInput = {
    where: TreeScalarWhereInput
    data: XOR<TreeUpdateManyMutationInput, TreeUncheckedUpdateManyWithoutRoadInput>
  }

  export type TreeScalarWhereInput = {
    AND?: TreeScalarWhereInput | TreeScalarWhereInput[]
    OR?: TreeScalarWhereInput[]
    NOT?: TreeScalarWhereInput | TreeScalarWhereInput[]
    id?: StringFilter<"Tree"> | string
    latitude?: FloatFilter<"Tree"> | number
    longitude?: FloatFilter<"Tree"> | number
    species?: StringNullableFilter<"Tree"> | string | null
    age?: IntNullableFilter<"Tree"> | number | null
    trunk_diameter?: FloatNullableFilter<"Tree"> | number | null
    lbranch_width?: FloatNullableFilter<"Tree"> | number | null
    ownership?: StringNullableFilter<"Tree"> | string | null
    description?: StringNullableFilter<"Tree"> | string | null
    roadName?: StringNullableFilter<"Tree"> | string | null
    status?: EnumTreeStatusFilter<"Tree"> | $Enums.TreeStatus
    timestamp?: DateTimeFilter<"Tree"> | Date | string
    roadId?: StringNullableFilter<"Tree"> | string | null
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    verified?: ReportCreateNestedManyWithoutVerifiedByInput
    resolved?: ReportCreateNestedManyWithoutResolvedByInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    verified?: ReportUncheckedCreateNestedManyWithoutVerifiedByInput
    resolved?: ReportUncheckedCreateNestedManyWithoutResolvedByInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type TreeCreateWithoutReportsInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    road?: RoadCreateNestedOneWithoutTreesInput
    treePictures?: TreePictureCreateNestedManyWithoutTreeInput
  }

  export type TreeUncheckedCreateWithoutReportsInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    roadId?: string | null
    treePictures?: TreePictureUncheckedCreateNestedManyWithoutTreeInput
  }

  export type TreeCreateOrConnectWithoutReportsInput = {
    where: TreeWhereUniqueInput
    create: XOR<TreeCreateWithoutReportsInput, TreeUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutVerifiedInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportCreateNestedManyWithoutUserInput
    resolved?: ReportCreateNestedManyWithoutResolvedByInput
  }

  export type UserUncheckedCreateWithoutVerifiedInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    resolved?: ReportUncheckedCreateNestedManyWithoutResolvedByInput
  }

  export type UserCreateOrConnectWithoutVerifiedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedInput, UserUncheckedCreateWithoutVerifiedInput>
  }

  export type UserCreateWithoutResolvedInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportCreateNestedManyWithoutUserInput
    verified?: ReportCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutResolvedInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    phone?: string | null
    userpic?: string | null
    bio?: string | null
    address?: string | null
    country?: string | null
    province?: string | null
    city?: string | null
    postalcode?: string | null
    role?: $Enums.Role
    timestamp?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    verified?: ReportUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedInput, UserUncheckedCreateWithoutResolvedInput>
  }

  export type ReportPictureCreateWithoutReportInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type ReportPictureUncheckedCreateWithoutReportInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type ReportPictureCreateOrConnectWithoutReportInput = {
    where: ReportPictureWhereUniqueInput
    create: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput>
  }

  export type ReportPictureCreateManyReportInputEnvelope = {
    data: ReportPictureCreateManyReportInput | ReportPictureCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: ReportUpdateManyWithoutVerifiedByNestedInput
    resolved?: ReportUpdateManyWithoutResolvedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: ReportUncheckedUpdateManyWithoutVerifiedByNestedInput
    resolved?: ReportUncheckedUpdateManyWithoutResolvedByNestedInput
  }

  export type TreeUpsertWithoutReportsInput = {
    update: XOR<TreeUpdateWithoutReportsInput, TreeUncheckedUpdateWithoutReportsInput>
    create: XOR<TreeCreateWithoutReportsInput, TreeUncheckedCreateWithoutReportsInput>
    where?: TreeWhereInput
  }

  export type TreeUpdateToOneWithWhereWithoutReportsInput = {
    where?: TreeWhereInput
    data: XOR<TreeUpdateWithoutReportsInput, TreeUncheckedUpdateWithoutReportsInput>
  }

  export type TreeUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    road?: RoadUpdateOneWithoutTreesNestedInput
    treePictures?: TreePictureUpdateManyWithoutTreeNestedInput
  }

  export type TreeUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roadId?: NullableStringFieldUpdateOperationsInput | string | null
    treePictures?: TreePictureUncheckedUpdateManyWithoutTreeNestedInput
  }

  export type UserUpsertWithoutVerifiedInput = {
    update: XOR<UserUpdateWithoutVerifiedInput, UserUncheckedUpdateWithoutVerifiedInput>
    create: XOR<UserCreateWithoutVerifiedInput, UserUncheckedCreateWithoutVerifiedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedInput, UserUncheckedUpdateWithoutVerifiedInput>
  }

  export type UserUpdateWithoutVerifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutUserNestedInput
    resolved?: ReportUpdateManyWithoutResolvedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    resolved?: ReportUncheckedUpdateManyWithoutResolvedByNestedInput
  }

  export type UserUpsertWithoutResolvedInput = {
    update: XOR<UserUpdateWithoutResolvedInput, UserUncheckedUpdateWithoutResolvedInput>
    create: XOR<UserCreateWithoutResolvedInput, UserUncheckedCreateWithoutResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedInput, UserUncheckedUpdateWithoutResolvedInput>
  }

  export type UserUpdateWithoutResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutUserNestedInput
    verified?: ReportUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userpic?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    verified?: ReportUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ReportPictureUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportPictureWhereUniqueInput
    update: XOR<ReportPictureUpdateWithoutReportInput, ReportPictureUncheckedUpdateWithoutReportInput>
    create: XOR<ReportPictureCreateWithoutReportInput, ReportPictureUncheckedCreateWithoutReportInput>
  }

  export type ReportPictureUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportPictureWhereUniqueInput
    data: XOR<ReportPictureUpdateWithoutReportInput, ReportPictureUncheckedUpdateWithoutReportInput>
  }

  export type ReportPictureUpdateManyWithWhereWithoutReportInput = {
    where: ReportPictureScalarWhereInput
    data: XOR<ReportPictureUpdateManyMutationInput, ReportPictureUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportPictureScalarWhereInput = {
    AND?: ReportPictureScalarWhereInput | ReportPictureScalarWhereInput[]
    OR?: ReportPictureScalarWhereInput[]
    NOT?: ReportPictureScalarWhereInput | ReportPictureScalarWhereInput[]
    id?: StringFilter<"ReportPicture"> | string
    url?: StringFilter<"ReportPicture"> | string
    reportId?: StringFilter<"ReportPicture"> | string
    uploaded?: DateTimeFilter<"ReportPicture"> | Date | string
  }

  export type TreeCreateWithoutTreePicturesInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    road?: RoadCreateNestedOneWithoutTreesInput
    reports?: ReportCreateNestedManyWithoutTreeInput
  }

  export type TreeUncheckedCreateWithoutTreePicturesInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
    roadId?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutTreeInput
  }

  export type TreeCreateOrConnectWithoutTreePicturesInput = {
    where: TreeWhereUniqueInput
    create: XOR<TreeCreateWithoutTreePicturesInput, TreeUncheckedCreateWithoutTreePicturesInput>
  }

  export type TreeUpsertWithoutTreePicturesInput = {
    update: XOR<TreeUpdateWithoutTreePicturesInput, TreeUncheckedUpdateWithoutTreePicturesInput>
    create: XOR<TreeCreateWithoutTreePicturesInput, TreeUncheckedCreateWithoutTreePicturesInput>
    where?: TreeWhereInput
  }

  export type TreeUpdateToOneWithWhereWithoutTreePicturesInput = {
    where?: TreeWhereInput
    data: XOR<TreeUpdateWithoutTreePicturesInput, TreeUncheckedUpdateWithoutTreePicturesInput>
  }

  export type TreeUpdateWithoutTreePicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    road?: RoadUpdateOneWithoutTreesNestedInput
    reports?: ReportUpdateManyWithoutTreeNestedInput
  }

  export type TreeUncheckedUpdateWithoutTreePicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roadId?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutTreeNestedInput
  }

  export type RoadCreateWithoutRoadPicturesInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    trees?: TreeCreateNestedManyWithoutRoadInput
  }

  export type RoadUncheckedCreateWithoutRoadPicturesInput = {
    id?: string
    nameroad?: string | null
    description?: string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: string | null
    osm_type?: string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: $Enums.RoadColor | null
    status?: $Enums.RoadStatus
    trees?: TreeUncheckedCreateNestedManyWithoutRoadInput
  }

  export type RoadCreateOrConnectWithoutRoadPicturesInput = {
    where: RoadWhereUniqueInput
    create: XOR<RoadCreateWithoutRoadPicturesInput, RoadUncheckedCreateWithoutRoadPicturesInput>
  }

  export type RoadUpsertWithoutRoadPicturesInput = {
    update: XOR<RoadUpdateWithoutRoadPicturesInput, RoadUncheckedUpdateWithoutRoadPicturesInput>
    create: XOR<RoadCreateWithoutRoadPicturesInput, RoadUncheckedCreateWithoutRoadPicturesInput>
    where?: RoadWhereInput
  }

  export type RoadUpdateToOneWithWhereWithoutRoadPicturesInput = {
    where?: RoadWhereInput
    data: XOR<RoadUpdateWithoutRoadPicturesInput, RoadUncheckedUpdateWithoutRoadPicturesInput>
  }

  export type RoadUpdateWithoutRoadPicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    trees?: TreeUpdateManyWithoutRoadNestedInput
  }

  export type RoadUncheckedUpdateWithoutRoadPicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameroad?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    geometry?: NullableJsonNullValueInput | InputJsonValue
    source_osm_id?: NullableStringFieldUpdateOperationsInput | string | null
    osm_type?: NullableStringFieldUpdateOperationsInput | string | null
    osm_tags?: NullableJsonNullValueInput | InputJsonValue
    osm_properties?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableEnumRoadColorFieldUpdateOperationsInput | $Enums.RoadColor | null
    status?: EnumRoadStatusFieldUpdateOperationsInput | $Enums.RoadStatus
    trees?: TreeUncheckedUpdateManyWithoutRoadNestedInput
  }

  export type ReportCreateWithoutReportPicturesInput = {
    id?: string
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReportsInput
    tree?: TreeCreateNestedOneWithoutReportsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedInput
  }

  export type ReportUncheckedCreateWithoutReportPicturesInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReportPicturesInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportPicturesInput, ReportUncheckedCreateWithoutReportPicturesInput>
  }

  export type ReportUpsertWithoutReportPicturesInput = {
    update: XOR<ReportUpdateWithoutReportPicturesInput, ReportUncheckedUpdateWithoutReportPicturesInput>
    create: XOR<ReportCreateWithoutReportPicturesInput, ReportUncheckedCreateWithoutReportPicturesInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutReportPicturesInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutReportPicturesInput, ReportUncheckedUpdateWithoutReportPicturesInput>
  }

  export type ReportUpdateWithoutReportPicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReportsNestedInput
    tree?: TreeUpdateOneWithoutReportsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportPicturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyUserInput = {
    id?: string
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type ReportCreateManyVerifiedByInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type ReportCreateManyResolvedByInput = {
    id?: string
    userId?: string | null
    treeId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type ReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tree?: TreeUpdateOneWithoutReportsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedNestedInput
    reportPictures?: ReportPictureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportPictures?: ReportPictureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReportsNestedInput
    tree?: TreeUpdateOneWithoutReportsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedNestedInput
    reportPictures?: ReportPictureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportPictures?: ReportPictureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReportsNestedInput
    tree?: TreeUpdateOneWithoutReportsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedNestedInput
    reportPictures?: ReportPictureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportPictures?: ReportPictureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    treeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyTreeInput = {
    id?: string
    userId?: string | null
    description?: string | null
    status?: $Enums.ReportStatus
    timestamp?: Date | string
    verifiedById?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
  }

  export type TreePictureCreateManyTreeInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type ReportUpdateWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReportsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedNestedInput
    reportPictures?: ReportPictureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportPictures?: ReportPictureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TreePictureUpdateWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreePictureUncheckedUpdateWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreePictureUncheckedUpdateManyWithoutTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureCreateManyRoadInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type TreeCreateManyRoadInput = {
    id?: string
    latitude: number
    longitude: number
    species?: string | null
    age?: number | null
    trunk_diameter?: number | null
    lbranch_width?: number | null
    ownership?: string | null
    description?: string | null
    roadName?: string | null
    status?: $Enums.TreeStatus
    timestamp?: Date | string
  }

  export type RoadPictureUpdateWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureUncheckedUpdateWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadPictureUncheckedUpdateManyWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreeUpdateWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutTreeNestedInput
    treePictures?: TreePictureUpdateManyWithoutTreeNestedInput
  }

  export type TreeUncheckedUpdateWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTreeNestedInput
    treePictures?: TreePictureUncheckedUpdateManyWithoutTreeNestedInput
  }

  export type TreeUncheckedUpdateManyWithoutRoadInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    species?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    trunk_diameter?: NullableFloatFieldUpdateOperationsInput | number | null
    lbranch_width?: NullableFloatFieldUpdateOperationsInput | number | null
    ownership?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTreeStatusFieldUpdateOperationsInput | $Enums.TreeStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureCreateManyReportInput = {
    id?: string
    url: string
    uploaded?: Date | string
  }

  export type ReportPictureUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPictureUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreeCountOutputTypeDefaultArgs instead
     */
    export type TreeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadCountOutputTypeDefaultArgs instead
     */
    export type RoadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreeDefaultArgs instead
     */
    export type TreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadDefaultArgs instead
     */
    export type RoadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreePictureDefaultArgs instead
     */
    export type TreePictureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreePictureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadPictureDefaultArgs instead
     */
    export type RoadPictureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadPictureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportPictureDefaultArgs instead
     */
    export type ReportPictureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportPictureDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}